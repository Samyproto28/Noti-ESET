{
  "master": {
    "tasks": [
      {
        "id": "1",
        "title": "Configurar proyecto Next.js 14 con App Router",
        "description": "Inicializar proyecto Next.js 14 con React Server Components y App Router configurado para mobile-first",
        "details": "Usar Next.js 14.2+ con create-next-app, configurar App Router, setup para TypeScript, Tailwind CSS v3.4+, y optimización para mobile-first con breakpoints personalizados",
        "testStrategy": "Verificar que el proyecto inicie correctamente, que las páginas se rendericen del lado del servidor, y que el diseño sea responsive en mobile, tablet y desktop",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Inicializar proyecto Next.js 14 con create-next-app",
            "description": "Crear nueva aplicación Next.js 14 usando el CLI de create-next-app con configuración básica para TypeScript y Tailwind CSS v3.4+",
            "dependencies": [],
            "details": "Ejecutar `npx create-next-app@latest noticet --typescript --tailwind --eslint --app --src-dir --import-alias '@/*'`. Configurar package.json con scripts para desarrollo y producción. Verificar estructura de carpetas generada automáticamente.",
            "status": "done",
            "testStrategy": "Verificar que el proyecto se crea correctamente con `npm run dev`, confirmar estructura de archivos, y validar que TypeScript y Tailwind estén configurados",
            "parentId": "undefined",
            "updatedAt": "2025-11-30T21:04:24.397Z"
          },
          {
            "id": 2,
            "title": "Configurar Tailwind CSS para mobile-first y breakpoints personalizados",
            "description": "Establecer configuración de Tailwind CSS con breakpoints personalizados según especificaciones: Mobile (<640px), Tablet (640-1024px), Desktop (>1024px)",
            "dependencies": [
              1
            ],
            "details": "Configurar tailwind.config.js con breakpoints personalizados. Instalar y configurar @tailwindcss/forms y @tailwindcss/typography. Establecer sistema de diseño responsive con single-column para mobile, 2-column para tablet, y multi-column para desktop. Configurar touch targets mínimos de 44x44px.",
            "status": "done",
            "testStrategy": "Probar diseño responsive usando Chrome DevTools para diferentes tamaños de pantalla, validar breakpoints en mobile/tablet/desktop, y verificar tamaños de touch targets",
            "parentId": "undefined",
            "updatedAt": "2025-11-30T18:50:23.953Z"
          },
          {
            "id": 3,
            "title": "Crear estructura de archivos y carpetas base del proyecto",
            "description": "Organizar estructura del proyecto con carpetas para components, pages, hooks, utils, types, y configuración inicial del App Router",
            "dependencies": [
              1
            ],
            "details": "Crear carpetas: src/components (UI y features), src/hooks, src/utils, src/types, src/lib, src/styles. Configurar layout principal en app/layout.tsx. Crear página principal en app/page.tsx. Establecer estructura de archivos para Server Components. Configurar archivo globals.css con estilos base.",
            "status": "done",
            "testStrategy": "Verificar que todas las carpetas se creen correctamente, probar que la aplicación cargue sin errores, y validar estructura de archivos Next.js 14",
            "parentId": "undefined",
            "updatedAt": "2025-11-30T18:53:10.575Z"
          },
          {
            "id": 4,
            "title": "Configurar sistema de build y variables de entorno",
            "description": "Establecer configuración de build para desarrollo y producción, configurar variables de entorno necesarias para el proyecto",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Configurar next.config.js con optimizaciones para producción. Crear archivos .env.local y .env.example. Configurar TypeScript para modo estricto. Establecer scripts npm para desarrollo, build, y lint. Configurar ESLint y Prettier si es necesario. Verificar que el sistema de build funcione correctamente.",
            "status": "done",
            "testStrategy": "Ejecutar `npm run build` y verificar que compile sin errores, probar `npm run dev`, y validar que las variables de entorno se carguen correctamente",
            "parentId": "undefined",
            "updatedAt": "2025-11-30T18:51:17.333Z"
          }
        ],
        "complexity": 3,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Crear estructura inicial del proyecto Next.js 14 con App Router, configurar TypeScript, Tailwind CSS v3.4+, y mobile-first. Establecer sistema de build y desarrollo.",
        "updatedAt": "2025-11-30T21:04:24.397Z"
      },
      {
        "id": "2",
        "title": "Configurar Tailwind CSS mobile-first",
        "description": "Implementar sistema de diseño responsive con Tailwind CSS siguiendo especificaciones del PRD",
        "details": "Configurar Tailwind CSS con breakpoints personalizados: Mobile (<640px): full width, botones 48px+, single-column. Tablet (640-1024px): 2-column, touch-optimized. Desktop (>1024px): multi-column, sidebar, 3+ column grids. Usar @tailwindcss/forms y @tailwindcss/typography",
        "testStrategy": "Verificar diseño responsive en Chrome DevTools para diferentes tamaños de pantalla, validar tamaños de touch targets (44x44px mínimo), y comprobar layouts según especificaciones",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Configurar Tailwind CSS y dependencias",
            "description": "Instalar Tailwind CSS v3.4+ con plugins de forms y typography, y configurar el proyecto para la migración desde CSS vanilla",
            "dependencies": [],
            "details": "Instalar tailwindcss@latest @tailwindcss/forms @tailwindcss/typography. Configurar tailwind.config.js con breakpoints personalizados: sm: '640px', md: '1024px'. Agregar configuración de content paths para archivos .js, .jsx, .ts, .tsx, .html. Inicializar archivos base tailwind.css en el proyecto.",
            "status": "done",
            "testStrategy": "Verificar instalación exitosa con npx tailwindcss -i, validar configuración de breakpoints, y confirmar que los plugins estén activos",
            "parentId": "undefined",
            "updatedAt": "2025-11-30T23:15:33.491Z"
          },
          {
            "id": 2,
            "title": "Migrar estilos base y estructura móvil",
            "description": "Convertir estilos CSS vanilla existentes a clases Tailwind CSS para el breakpoint móvil (<640px) con diseño mobile-first",
            "dependencies": [
              1
            ],
            "details": "Analizar los 354 lines de CSS vanilla actual. Identificar estilos base para elementos HTML comunes. Convertir a clases Tailwind: full-width (w-full), botones de 48px+ (py-3 px-6 text-lg), layout single-column (block). Implementar estilos mobile-first como base progresiva.",
            "status": "done",
            "testStrategy": "Validar en Chrome DevTools con viewport móvil (<640px), verificar touch targets >=44x44px, y comprobar que todos los elementos mantengan su apariencia",
            "parentId": "undefined",
            "updatedAt": "2025-11-30T21:31:55.936Z"
          },
          {
            "id": 3,
            "title": "Implementar diseño tablet responsive",
            "description": "Configurar estilos Tailwind CSS para breakpoint tablet (640px-1024px) con layout optimizado para touch",
            "dependencies": [
              2
            ],
            "details": "Implementar clases con prefijo md: para layouts de 2 columnas (md:grid-cols-2, md:gap-4). Optimizar elementos touch con tamaños adecuados (md:min-h-[44px] md:min-w-[44px]). Configurar márgenes y padding responsive. Ajustar tipografía para tablet (md:text-base).",
            "status": "done",
            "testStrategy": "Probar en tablet mode en Chrome DevTools (640px-1024px), verificar layouts de 2 columnas, validar touch targets optimizados, y comprobar navegación táctil",
            "parentId": "undefined",
            "updatedAt": "2025-11-30T21:33:51.450Z"
          },
          {
            "id": 4,
            "title": "Configurar diseño desktop multi-column",
            "description": "Implementar layouts desktop (>1024px) con múltiples columnas, sidebar y grids de 3+ columnas",
            "dependencies": [
              3
            ],
            "details": "Configurar clases con prefijo lg: para layouts avanzados: lg:grid-cols-3+, lg:flex lg:flex-row, sidebar fijo (lg:fixed lg:w-64). Implementar grids complejos con lg:grid lg:grid-cols-4. Configurar tipografía desktop (lg:text-lg). Ajustar espaciado y márgenes para pantallas grandes.",
            "status": "done",
            "testStrategy": "Validar en desktop mode (>1024px), verificar layouts multi-column, probar sidebar funcional, y comprobar grids de 3+ columnas",
            "parentId": "undefined",
            "updatedAt": "2025-11-30T23:15:54.167Z"
          },
          {
            "id": 5,
            "title": "Optimizar y limpiar código CSS residual",
            "description": "Eliminar CSS vanilla original y optimizar clases Tailwind CSS para producción",
            "dependencies": [
              4
            ],
            "details": "Eliminar archivo CSS vanilla original después de validación completa. Revisar y optimizar clases Tailwind duplicadas. Configurar PurgeCSS para remover clases no utilizadas en producción. Optimizar bundle size con tree-shaking. Verificar consistencia visual en todos los breakpoints.",
            "status": "done",
            "testStrategy": "Verificar que el CSS vanilla haya sido eliminado completamente, probar optimización en modo producción, y validar consistencia visual final",
            "parentId": "undefined",
            "updatedAt": "2025-11-30T23:16:57.619Z"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Migrar de CSS vanilla a Tailwind CSS v3.4+ implementando sistema mobile-first con breakpoints personalizados. Configurar @tailwindcss/forms y @tailwindcss/typography. Reemplazar estilos existentes.",
        "updatedAt": "2025-11-30T23:16:57.619Z"
      },
      {
        "id": "3",
        "title": "Configurar Supabase Database y Auth",
        "description": "Establecer conexión con Supabase PostgreSQL y configurar sistema de autenticación JWT",
        "details": "Crear proyecto Supabase, configurar variables de entorno (NEXT_PUBLIC_SUPABASE_URL, NEXT_PUBLIC_SUPABASE_ANON_KEY), instalar @supabase/supabase-js v2.39+, y configurar cliente Supabase para Row Level Security",
        "testStrategy": "Verificar conexión exitosa con Supabase, probar autenticación con emails @eset.edu.ar, y confirmar que las variables de entorno estén configuradas correctamente",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Instalar dependencias de Supabase y configurar variables de entorno",
            "description": "Instalar @supabase/supabase-js v2.39+ y configurar las variables de entorno NEXT_PUBLIC_SUPABASE_URL y NEXT_PUBLIC_SUPABASE_ANON_KEY en el proyecto Next.js",
            "dependencies": [],
            "details": "Ejecutar npm install @supabase/supabase-js@^2.39.0. Configurar variables de entorno en .env.local verificando que las credenciales existentes en .env sean correctas. Asegurar que las variables sigan el formato NEXT_PUBLIC_ para que sean accesibles en el cliente.",
            "status": "pending",
            "testStrategy": "Verificar instalación correcta del paquete npm y que las variables de entorno sean accesibles en el código del cliente con process.env.NEXT_PUBLIC_SUPABASE_URL",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Crear cliente Supabase y configurar utilidades de autenticación",
            "description": "Crear archivo de configuración del cliente Supabase y funciones helper para autenticación JWT",
            "dependencies": [
              1
            ],
            "details": "Crear lib/supabase.js (o utils/supabase.ts) con la configuración del cliente Supabase usando las variables de entorno. Implementar funciones para signUp, signIn, signOut, y getCurrentUser. Configurar provider de contexto de autenticación para React.",
            "status": "pending",
            "testStrategy": "Probar que el cliente Supabase se inicializa correctamente y que las funciones de autenticación básicas retornan respuestas esperadas",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar componentes de autenticación UI",
            "description": "Crear componentes de React para formulario de login, registro y manejo de sesión",
            "dependencies": [
              2
            ],
            "details": "Crear componente LoginForm con email y password para @eset.edu.ar. Crear SignUpForm con validación de email institucional. Implementar AuthProvider con contexto de React para manejar estado de autenticación. Crear ProtectedRoute para rutas seguras.",
            "status": "pending",
            "testStrategy": "Verificar renderizado correcto de formularios, validación de inputs, y que el estado de autenticación se actualice correctamente",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Configurar Row Level Security (RLS) en Supabase",
            "description": "Establecer políticas de seguridad a nivel de fila en tablas de Supabase para control de acceso",
            "dependencies": [
              1
            ],
            "details": "Conectarse a Supabase Dashboard y configurar RLS para las tablas principales (users, posts, comments). Crear políticas para: usuarios solo ven/editan sus propios datos, posts públicos son visibles para todos pero editables solo por autor, comentarios siguen reglas similares. Habilitar RLS en todas las tablas.",
            "status": "pending",
            "testStrategy": "Probar acceso a datos con diferentes usuarios y verificar que las políticas de RLS funcionen correctamente (usuarios no autorizados no pueden acceder)",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implementar middleware de autenticación en Next.js",
            "description": "Crear middleware para proteger rutas y verificar sesiones JWT",
            "dependencies": [
              2,
              3
            ],
            "details": "Crear middleware.ts en la raíz del proyecto para interceptar rutas protegidas. Verificar tokens JWT usando el cliente Supabase. Implementar redirecciones a /login para usuarios no autenticados. Configurar rutas públicas y privadas. Manejar refresh de tokens automáticamente.",
            "status": "pending",
            "testStrategy": "Verificar que usuarios no autenticados sean redirigidos a login, que usuarios autenticados puedan acceder a rutas protegidas, y que el refresh de tokens funcione correctamente",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Integrar autenticación con flujo principal de la aplicación",
            "description": "Conectar el sistema de autenticación con el resto de la aplicación y probar flujo completo",
            "dependencies": [
              4,
              5
            ],
            "details": "Actualizar componentes principales para usar el estado de autenticación. Implementar persistencia de sesión usando localStorage o Supabase auth helpers. Configurar redirección después de login/logout. Actualizar navigation para mostrar opciones según estado de autenticación. Probar flujo completo desde registro hasta uso de la aplicación.",
            "status": "pending",
            "testStrategy": "Probar flujo completo de registro, login, uso de features protegidas, logout y verify que la sesión persista correctamente al recargar la página",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 6,
        "expansionPrompt": "Configurar conexión Supabase PostgreSQL, instalar @supabase/supabase-js v2.39+, configurar variables de entorno NEXT_PUBLIC_SUPABASE_URL y NEXT_PUBLIC_SUPABASE_ANON_KEY. Setup de cliente Supabase y Row Level Security.",
        "updatedAt": "2025-12-01T01:28:11.720Z"
      },
      {
        "id": "4",
        "title": "Crear schema de base de datos en Supabase",
        "description": "Implementar estructura de tablas según especificaciones técnicas del PRD",
        "details": "Ejecutar migraciones SQL para crear tablas: users (id UUID PK, email UNIQUE, role con CHECK), news (id UUID PK, category CHECK, author_id FK), comments (id UUID PK, parent_comment_id FK para jerarquía), reactions (UNIQUE constraint), forum_topics, images. Crear índices optimizados para performance",
        "testStrategy": "Validar que todas las tablas se creen con constraints correctos, verificar índices para búsquedas rápidas, y probar relaciones foreign key con datos de prueba",
        "priority": "high",
        "dependencies": [
          "3"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear tabla users con UUID y constraints",
            "description": "Implementar la tabla principal de usuarios con UUID como clave primaria, email único y roles con validación CHECK",
            "dependencies": [],
            "details": "Crear migración SQL para tabla users con: id UUID PRIMARY KEY DEFAULT gen_random_uuid(), email VARCHAR UNIQUE NOT NULL, role VARCHAR CHECK (role IN ('admin', 'editor', 'user')), created_at TIMESTAMP DEFAULT NOW(), updated_at TIMESTAMP DEFAULT NOW()",
            "status": "done",
            "testStrategy": "Verificar creación de tabla, probar inserción con diferentes roles, validar constraint UNIQUE en email",
            "parentId": "undefined",
            "updatedAt": "2025-12-01T03:33:46.106Z"
          },
          {
            "id": 2,
            "title": "Crear tabla news con categorías y autor",
            "description": "Implementar tabla de noticias con UUID, categorías validadas, y relación con tabla users",
            "dependencies": [
              1
            ],
            "details": "Crear migración para tabla news con: id UUID PRIMARY KEY DEFAULT gen_random_uuid(), title VARCHAR NOT NULL, content TEXT, category VARCHAR CHECK (category IN ('national', 'international', 'technology', 'sports', 'culture')), author_id UUID REFERENCES users(id) ON DELETE CASCADE, created_at TIMESTAMP DEFAULT NOW()",
            "status": "done",
            "testStrategy": "Probar inserción de noticias con diferentes categorías, validar foreign key constraint con users",
            "parentId": "undefined",
            "updatedAt": "2025-12-01T03:34:47.307Z"
          },
          {
            "id": 3,
            "title": "Crear tabla comments con estructura jerárquica",
            "description": "Implementar sistema de comentarios con soporte para respuestas mediante auto-referencia",
            "dependencies": [
              1,
              2
            ],
            "details": "Crear migración para tabla comments con: id UUID PRIMARY KEY DEFAULT gen_random_uuid(), content TEXT NOT NULL, user_id UUID REFERENCES users(id) ON DELETE CASCADE, news_id UUID REFERENCES news(id) ON DELETE CASCADE, parent_comment_id UUID REFERENCES comments(id) ON DELETE SET NULL, created_at TIMESTAMP DEFAULT NOW()",
            "status": "done",
            "testStrategy": "Probar comentarios principales y respuestas, validar eliminación en cascada correcta",
            "parentId": "undefined",
            "updatedAt": "2025-12-01T03:35:47.364Z"
          },
          {
            "id": 4,
            "title": "Crear tabla reactions con constraint único",
            "description": "Implementar tabla de reacciones con validación para evitar múltiples reacciones del mismo usuario",
            "dependencies": [
              1,
              2
            ],
            "details": "Crear migración para tabla reactions con: id UUID PRIMARY KEY DEFAULT gen_random_uuid(), user_id UUID REFERENCES users(id) ON DELETE CASCADE, news_id UUID REFERENCES news(id) ON DELETE CASCADE, reaction_type VARCHAR CHECK (reaction_type IN ('like', 'love', 'laugh', 'angry', 'sad')), created_at TIMESTAMP DEFAULT NOW(), UNIQUE(user_id, news_id)",
            "status": "done",
            "testStrategy": "Verificar constraint único por usuario-noticia, probar diferentes tipos de reacción",
            "parentId": "undefined",
            "updatedAt": "2025-12-01T03:37:24.628Z"
          },
          {
            "id": 5,
            "title": "Crear tabla forum_topics para discusiones",
            "description": "Implementar tabla para temas del foro con relación a usuarios creadores",
            "dependencies": [
              1
            ],
            "details": "Crear migración para tabla forum_topics con: id UUID PRIMARY KEY DEFAULT gen_random_uuid(), title VARCHAR NOT NULL, description TEXT, creator_id UUID REFERENCES users(id) ON DELETE CASCADE, is_sticky BOOLEAN DEFAULT FALSE, is_locked BOOLEAN DEFAULT FALSE, created_at TIMESTAMP DEFAULT NOW(), updated_at TIMESTAMP DEFAULT NOW()",
            "status": "done",
            "testStrategy": "Probar creación de temas, validar sticky y locked flags, verificar relación con usuarios",
            "parentId": "undefined",
            "updatedAt": "2025-12-01T03:37:45.998Z"
          },
          {
            "id": 6,
            "title": "Crear tabla images para gestión multimedia",
            "description": "Implementar tabla para almacenar metadatos de imágenes con referencia a usuarios",
            "dependencies": [
              1
            ],
            "details": "Crear migración para tabla images con: id UUID PRIMARY KEY DEFAULT gen_random_uuid(), filename VARCHAR NOT NULL, original_name VARCHAR NOT NULL, mime_type VARCHAR NOT NULL, size_bytes INTEGER NOT NULL, uploader_id UUID REFERENCES users(id) ON DELETE CASCADE, storage_path VARCHAR NOT NULL, created_at TIMESTAMP DEFAULT NOW()",
            "status": "done",
            "testStrategy": "Verificar inserción de diferentes tipos de imagen, validar restricciones de tamaño y formato",
            "parentId": "undefined",
            "updatedAt": "2025-12-01T03:38:19.284Z"
          },
          {
            "id": 7,
            "title": "Crear índices optimizados para rendimiento",
            "description": "Implementar índices estratégicos para optimizar consultas frecuentes",
            "dependencies": [
              1,
              2,
              3,
              4,
              5,
              6
            ],
            "details": "Crear índices: CREATE INDEX idx_users_email ON users(email); CREATE INDEX idx_news_author_category ON news(author_id, category); CREATE INDEX idx_news_created_at ON news(created_at DESC); CREATE INDEX idx_comments_news_created ON comments(news_id, created_at); CREATE INDEX idx_comments_parent ON comments(parent_comment_id); CREATE INDEX idx_reactions_news ON reactions(news_id); CREATE INDEX idx_forum_topics_created ON forum_topics(created_at DESC); CREATE INDEX idx_images_uploader ON images(uploader_id)",
            "status": "done",
            "testStrategy": "Ejecutar EXPLAIN ANALYZE en consultas típicas para verificar uso de índices, medir rendimiento antes y después",
            "parentId": "undefined",
            "updatedAt": "2025-12-01T03:38:44.068Z"
          },
          {
            "id": 8,
            "title": "Validar schema completo con Row Level Security",
            "description": "Configurar políticas RLS en Supabase y probar integridad referencial completa",
            "dependencies": [
              1,
              2,
              3,
              4,
              5,
              6,
              7
            ],
            "details": "Habilitar RLS en todas las tablas, crear políticas básicas de seguridad, probar inserciones y actualizaciones, validar constraints CHECK y UNIQUE, probar eliminación en cascada, verificar performance con datos de prueba",
            "status": "done",
            "testStrategy": "Ejecutar suite completa de pruebas con datos de ejemplo, verificar todas las constraints, probar RLS con diferentes roles de usuario",
            "parentId": "undefined",
            "updatedAt": "2025-12-01T03:39:11.312Z"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 8,
        "expansionPrompt": "Diseñar e implementar schema SQL completo para la aplicación: users (UUID PK, email UNIQUE, role CHECK), news (UUID PK, category CHECK, author_id FK), comments (UUID PK, parent_comment_id FK), reactions (UNIQUE constraint), forum_topics, images. Crear índices optimizados.",
        "updatedAt": "2025-12-01T03:39:11.312Z"
      },
      {
        "id": "5",
        "title": "Implementar Row Level Security (RLS) policies",
        "description": "Configurar políticas de seguridad a nivel de base de datos según especificaciones",
        "details": "Crear políticas RLS: estudiantes solo ven sus propios perfiles, comentarios no aprobados solo visibles por autor y moderadores, diferentes niveles de acceso por rol (student, moderator, admin, superadmin). Implementar auditoría de cambios de rol",
        "testStrategy": "Probar cada política RLS con diferentes roles de usuario, verificar que estudiantes no puedan acceder a datos de otros estudiantes, y confirmar que moderadores puedan ver contenido pendiente de aprobación",
        "priority": "high",
        "dependencies": [
          "4"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Analizar estructura actual de la base de datos",
            "description": "Examinar tablas existentes en la base de datos para entender qué entidades necesitan políticas RLS",
            "dependencies": [],
            "details": "Explorar esquema actual de la base de datos identificando tablas de usuarios, posts, comentarios, roles y cualquier tabla que contenga información sensible que requiera protección a nivel de fila",
            "status": "done",
            "testStrategy": "Verificar lista completa de tablas y entender relaciones entre entidades",
            "parentId": "undefined",
            "updatedAt": "2025-12-01T04:12:53.806Z"
          },
          {
            "id": 2,
            "title": "Definir roles de usuario en PostgreSQL",
            "description": "Crear roles de base de datos para student, moderator, admin, superadmin",
            "dependencies": [],
            "details": "Implementar roles PostgreSQL con diferentes niveles de privilegio: student (acceso básico), moderator (acceso a contenido pendiente), admin (acceso completo), superadmin (acceso total sin restricciones)",
            "status": "done",
            "testStrategy": "Probar creación de roles y asignación de permisos básicos",
            "parentId": "undefined",
            "updatedAt": "2025-12-01T04:13:01.679Z"
          },
          {
            "id": 3,
            "title": "Implementar RLS para tabla de usuarios",
            "description": "Establecer política donde estudiantes solo ven y modifican su propio perfil",
            "dependencies": [
              1,
              2
            ],
            "details": "Crear política USING (user_id = current_user_id()) para operaciones SELECT, UPDATE, DELETE en la tabla usuarios, permitiendo roles administrativos ver todos los perfiles",
            "status": "done",
            "testStrategy": "Verificar que student_A no pueda acceder al perfil de student_B y que moderadores puedan ver todos los perfiles",
            "parentId": "undefined",
            "updatedAt": "2025-12-01T04:13:09.274Z"
          },
          {
            "id": 4,
            "title": "Implementar RLS para tabla de posts",
            "description": "Configurar políticas de acceso para posts según rol y estado",
            "dependencies": [
              1,
              2
            ],
            "details": "Crear políticas complejas: estudiantes solo ven posts publicados, moderadores ven posts pendientes de aprobación, admins ven todos los posts sin restricciones",
            "status": "done",
            "testStrategy": "Probar diferentes combinaciones de roles verificando visibilidad de posts según estado (pending/approved/rejected)",
            "parentId": "undefined",
            "updatedAt": "2025-12-01T04:13:14.587Z"
          },
          {
            "id": 5,
            "title": "Implementar RLS para tabla de comentarios",
            "description": "Establecer reglas para comentarios pendientes de aprobación",
            "dependencies": [
              1,
              2,
              4
            ],
            "details": "Políticas específicas: autores siempre ven sus comentarios, moderadores ven comentarios pendientes, estudiantes solo ven comentarios aprobados, admins ven todo",
            "status": "done",
            "testStrategy": "Verificar que estudiantes no vean comentarios pendientes y que autores puedan ver sus propios comentarios",
            "parentId": "undefined",
            "updatedAt": "2025-12-01T04:13:19.798Z"
          },
          {
            "id": 6,
            "title": "Crear tabla de auditoría de cambios",
            "description": "Diseñar estructura para registrar cambios de roles y acciones administrativas",
            "dependencies": [
              1
            ],
            "details": "Crear tabla audit_log con campos: id, user_id, old_role, new_role, action_type, timestamp, ip_address, additional_data con índices optimizados",
            "status": "done",
            "testStrategy": "Probar inserción de registros y verificar estructura correcta",
            "parentId": "undefined",
            "updatedAt": "2025-12-01T04:13:24.405Z"
          },
          {
            "id": 7,
            "title": "Implementar funciones de auditoría automática",
            "description": "Crear funciones PostgreSQL para registrar cambios de rol con timestamps",
            "dependencies": [
              6
            ],
            "details": "Desarrollar funciones PL/pgSQL que automaticamente registren cambios de rol en la tabla audit_log con timestamp actual y metadata relevante",
            "status": "done",
            "testStrategy": "Probar ejecución de funciones y verificar registros correctos en tabla de auditoría",
            "parentId": "undefined",
            "updatedAt": "2025-12-01T04:13:36.604Z"
          },
          {
            "id": 8,
            "title": "Configurar triggers para auditoría en tiempo real",
            "description": "Establecer triggers automáticos para capturar cambios de rol",
            "dependencies": [
              7
            ],
            "details": "Implementar triggers AFTER UPDATE en tablas de usuarios que automaticamente llamen a funciones de auditoría cuando cambie el campo de rol",
            "status": "done",
            "testStrategy": "Probar triggers modificando roles y verificando registros automáticos en auditoría",
            "parentId": "undefined",
            "updatedAt": "2025-12-01T04:13:42.337Z"
          },
          {
            "id": 9,
            "title": "Crear pruebas integrales de RLS y auditoría",
            "description": "Desarrollar suite de pruebas completas para todas las políticas RLS",
            "dependencies": [
              3,
              4,
              5,
              8
            ],
            "details": "Crear casos de prueba exhaustivos para cada combinación de rol y operación, incluyendo edge cases, intentos de acceso no autorizado y auditoría correcta",
            "status": "done",
            "testStrategy": "Ejecutar suite completa de pruebas verificando que todas las políticas funcionen correctamente y no haya brechas de seguridad",
            "parentId": "undefined",
            "updatedAt": "2025-12-01T04:14:06.727Z"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 9,
        "expansionPrompt": "Crear políticas RLS granulares: estudiantes solo ven sus propios perfiles, comentarios no aprobados solo visibles por autor y moderadores, diferentes niveles de acceso por rol (student, moderator, admin, superadmin). Implementar auditoría de cambios de rol.",
        "updatedAt": "2025-12-01T04:14:06.727Z"
      },
      {
        "id": "6",
        "title": "Diseñar y crear componentes UI base",
        "description": "Crear librería de componentes reutilizables con Tailwind CSS",
        "details": "Implementar componentes: Button (variantes primary/secondary/link, sizes responsive), Card, Modal, Form, Input, Select, Textarea, Loading states. Usar design system consistente con colores ESET (naranja #b60000, grises). Todos los componentes deben ser accesibles (WCAG 2.1 AA)",
        "testStrategy": "Verificar accesibilidad con axe DevTools, probar navegación por teclado, validar contrastes de colores, y comprobar responsive behavior en diferentes dispositivos",
        "priority": "medium",
        "dependencies": [
          "2"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configurar sistema de diseño base y tokens de color",
            "description": "Establecer configuración inicial de Tailwind CSS con tokens de diseño consistentes usando colores ESET (naranja #b60000 como primario, grises)",
            "dependencies": [],
            "details": "Configurar tailwind.config.js con colores personalizados, tipografía responsive, y tokens de espaciado. Definir sistema de colores con naranja (#b60000) como primario, grises para secundarios, y colores de estado (éxito, error, advertencia). Verificar contraste mínimo de 4.5:1 para WCAG 2.1 AA compliance.",
            "status": "pending",
            "testStrategy": "Validar contraste de colores con herramientas online, probar tokens de CSS en diferentes tamaños de pantalla",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Crear componente Button con variantes y accesibilidad",
            "description": "Implementar componente Button reutilizable con variantes primary/secondary/link y múltiples tamaños responsive",
            "dependencies": [
              1
            ],
            "details": "Crear componente Button.tsx con props: variant ('primary'|'secondary'|'link'), size ('sm'|'md'|'lg'|'xl'), disabled state, loading state. Implementar focus styles, aria-labels, keyboard navigation. Usar Tailwind classes consistentes con sistema de colores. Incluir loading spinner.",
            "status": "pending",
            "testStrategy": "Probar navegación por teclado, focus states, colores de contraste, y comportamiento responsive en diferentes tamaños",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Desarrollar componente Form con Input integrado",
            "description": "Crear componente Form contenedor y componente Input con validación y accesibilidad WCAG",
            "dependencies": [
              1
            ],
            "details": "Implementar Input.tsx con props: type, placeholder, error state, label, required, disabled. Incluir validación en tiempo real, mensajes de error, y aria attributes. Crear Form.tsx como contenedor con manejo de estado. Asegurar que todos los inputs tengan labels asociadas.",
            "status": "pending",
            "testStrategy": "Probar validación de formulario, navegación por tab, mensajes de error con screen readers, y diseño responsive",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implementar componentes Card y Select dropdown",
            "description": "Crear componentes Card para mostrar contenido y Select para selección de opciones",
            "dependencies": [
              1
            ],
            "details": "Card.tsx: props children, className opcional, shadow variants. Select.tsx: props options array, placeholder, onChange, disabled, error state. Implementar keyboard navigation para Select (arrows, enter, escape). Usar iconografía consistente.",
            "status": "pending",
            "testStrategy": "Verificar comportamiento del dropdown con teclado, accesibilidad de opciones, y diseño responsive en diferentes viewports",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Crear componente Modal con overlay y accesibilidad",
            "description": "Implementar Modal reutilizable con overlay, focus trapping, y navegación por teclado",
            "dependencies": [
              2
            ],
            "details": "Modal.tsx: props isOpen, onClose, children. Implementar overlay con backdrop blur, focus trap dentro del modal, close button con escape key, prevención de scroll en body. Usar portal para renderización correcta. Incluir role='dialog' y aria-modal.",
            "status": "pending",
            "testStrategy": "Probar focus trapping, navegación por tab dentro del modal, escape key functionality, y comportamiento en móviles",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Desarrollar componente Textarea y estados Loading",
            "description": "Crear Textarea multilinea y componentes de estado Loading reutilizables",
            "dependencies": [
              3
            ],
            "details": "Textarea.tsx: props rows, placeholder, resize options, maxLength. Loading components: Spinner, Skeleton, ProgressBar. Implementar diferentes tamaños y colores de loading. Asegurar que Loading components no afecten accesibilidad.",
            "status": "pending",
            "testStrategy": "Probar_resize de textarea, validación de maxLength, y que loading states no interfieran con screen readers",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Crear exportación de librería y documentación",
            "description": "Configurar exports de componentes y crear documentación de accesibilidad y uso",
            "dependencies": [
              2,
              3,
              4,
              5,
              6
            ],
            "details": "Crear index.ts barrel export de todos los componentes. Documentar cada componente con ejemplos, props de accesibilidad, y variantes disponibles. Incluir guías de WCAG compliance y keyboard navigation patterns. Preparar Storybook para desarrollo visual.",
            "status": "pending",
            "testStrategy": "Verificar que todos los componentes exporten correctamente, probar ejemplos de documentación, y validar accesibilidad con axe DevTools",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 7,
        "expansionPrompt": "Crear librería de componentes reutilizables con Tailwind CSS: Button (primary/secondary/link, sizes responsive), Card, Modal, Form, Input, Select, Textarea, Loading states. Design system consistente con colores ESET (naranja #b60000). WCAG 2.1 AA compliance."
      },
      {
        "id": "7",
        "title": "Implementar sistema de registro institucional",
        "description": "Crear formulario de registro validando dominio @eset.edu.ar con Supabase Auth",
        "details": "Formulario multi-step progresivo (email → password → confirmación). Validación frontend con Zod: email @eset.edu.ar requerido, contraseña 8+ caracteres con mayúscula, número y carácter especial. Implementar verificación de email con magic link de Supabase. UX mobile-first con <3 campos visibles por vez",
        "testStrategy": "Probar registro con email @eset.edu.ar válido, intentar registrar con email no autorizado (debe fallar), verificar flujo de confirmación por email, y validar UX responsive en mobile",
        "priority": "high",
        "dependencies": [
          "5",
          "6"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configurar esquema de validación con Zod",
            "description": "Crear esquemas de validación robustos para el formulario de registro institucional",
            "dependencies": [],
            "details": "Implementar validación de email con dominio @eset.edu.ar exclusivo usando regex específico. Validar contraseña con mínimo 8 caracteres, incluyendo mayúscula, número y carácter especial. Crear mensajes de error en español claro y específicos para cada caso de validación.",
            "status": "pending",
            "testStrategy": "Probar validación con email @eset.edu.ar válido, email de dominio no autorizado (debe rechazar), contraseña sin mayúscula (debe rechazar), contraseña sin número (debe rechazar), contraseña sin carácter especial (debe rechazar)",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Crear componente Multi-Step Register Form",
            "description": "Implementar formulario de registro progresivo con pasos email → password → confirmación",
            "dependencies": [
              1
            ],
            "details": "Diseñar componente React/Next.js con 3 pasos secuenciales. Implementar navegación entre pasos con botones Siguiente/Anterior. Mantener estado del formulario entre pasos. Diseño mobile-first con máximo 3 campos visibles simultáneamente. Loading states durante transiciones entre pasos.",
            "status": "pending",
            "testStrategy": "Probar navegación entre pasos, verificar que se mantienen datos al volver atrás, probar responsive en mobile (3 campos máx), verificar comportamiento con validación en cada paso",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Configurar Supabase Auth para registro institucional",
            "description": "Integrar Supabase Authentication con validación de dominio institucional",
            "dependencies": [
              1
            ],
            "details": "Configurar Supabase Auth con email provider. Implementar método signUp() con validación previa de dominio @eset.edu.ar. Configurar magic links para verificación de email. Manejar errores específicos de Supabase con mensajes en español. Configurar redirección post-verificación.",
            "status": "pending",
            "testStrategy": "Probar registro exitoso con @eset.edu.ar, intentar registro con email no autorizado (debe fallar), probar verificación de email, probar redirección post-verificación",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implementar estado global del formulario",
            "description": "Crear gestión de estado centralizado para el proceso de registro",
            "dependencies": [
              1
            ],
            "details": "Implementar contexto o Zustand para manejar estado del registro. Incluir campos: email, password, step actual, errores, loading status. Implementar acciones para actualizar estado, resetear formulario, manejar errores. Optimizar renderizado para evitar re-renders innecesarios.",
            "status": "pending",
            "testStrategy": "Probar persistencia de estado entre pasos, verificar reseteo del formulario, probar manejo concurrente de errores, verificar rendimiento con múltiples actualizaciones",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Crear UI de confirmación de email",
            "description": "Implementar pantalla de verificación de email con magic link",
            "dependencies": [
              2,
              3
            ],
            "details": "Diseñar pantalla mostrando mensaje de verificación enviado al email. Implementar polling automático para verificar estado de verificación. Crear opción para reenviar email de verificación. Mostrar email del usuario con máscara parcial. Diseño responsive mobile-first con UX clara.",
            "status": "pending",
            "testStrategy": "Probar que se muestre email correctamente, probar reenvío de email, verificar polling funciona, probar comportamiento cuando usuario verifica email",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Implementar manejo de errores y feedback UX",
            "description": "Crear sistema completo de manejo de errores con feedback visual",
            "dependencies": [
              2,
              3,
              5
            ],
            "details": "Crear toast/snackbar component para mostrar errores y éxitos. Implementar manejo específico para errores de red, Supabase, validación. Crear mensajes de error en español contextualizados. Implementar indicadores de loading específicos por acción. Manejar errores de conexión con retry automático.",
            "status": "pending",
            "testStrategy": "Probar diferentes tipos de errores (red, validación, Supabase), verificar mensajes en español, probar indicadores de loading, probar retry automático",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Optimizar UX mobile-first",
            "description": "Asegurar experiencia óptima en dispositivos móviles",
            "dependencies": [
              2,
              5,
              6
            ],
            "details": "Implementar diseño responsive con breakpoint mobile-first. Asegurar que solo 3 campos visibles simultáneamente. Optimizar touch targets mínimo 44px. Implementar scroll suave y focus management. Asegurar contraste WCAG para legibilidad en pantallas pequeñas. Optimizar performance para cargas rápidas en 3G.",
            "status": "pending",
            "testStrategy": "Probar en dispositivo móvil real, verificar 3 campos máx visibles, medir tiempo de carga en 3G, probar accesibilidad por touch, verificar contraste en sol directo",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Integrar flujo completo y testing E2E",
            "description": "Unificar todos los componentes y realizar testing integral",
            "dependencies": [
              4,
              7
            ],
            "details": "Integrar todos los componentes del flujo de registro. Implementar tests unitarios para validación Zod. Crear tests de integración para Supabase Auth. Implementar tests E2E con Cypress/Playwright cubriendo flujo completo. Configurar analytics para tracking de conversion de registro. Documentar API interna del componente.",
            "status": "pending",
            "testStrategy": "Ejecutar flujo completo de registro con email @eset.edu.ar, intentar registro con email no válido, probar verificación de email, verificar todos los casos de edge, probar en múltiples navegadores y dispositivos",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 8,
        "expansionPrompt": "Crear formulario de registro multi-step progresivo con validación @eset.edu.ar exclusiva. Validación frontend con Zod (email @eset.edu.ar, contraseña 8+ caracteres con mayúscula, número y carácter especial). Integrar verificación email con magic link Supabase. UX mobile-first."
      },
      {
        "id": "8",
        "title": "Implementar sistema de login JWT",
        "description": "Crear sistema de autenticación seguro con JWT tokens y refresh tokens",
        "details": "Usar Supabase Auth con signInWithPassword. Access tokens 1 hora, refresh tokens 30 días. Implementar rate limiting (5 intentos fallidos/IP en 15 min). Configurar middleware Next.js para proteger rutas. Protección CSRF en formularios. Logout limpiando cookies y tokens",
        "testStrategy": "Probar login exitoso con credenciales válidas, intentar login con contraseña incorrecta (debe ser rate limited), verificar que los tokens expiren correctamente, y confirmar que middleware proteja rutas privadas",
        "priority": "high",
        "dependencies": [
          "7"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configurar Supabase Auth y variables de entorno",
            "description": "Configurar cliente Supabase con variables de entorno para autenticación JWT",
            "dependencies": [],
            "details": "Instalar @supabase/supabase-js si no está. Crear cliente Supabase con URL y anon key. Configurar variables de entorno .env.local para NEXT_PUBLIC_SUPABASE_URL y NEXT_PUBLIC_SUPABASE_ANON_KEY. Probar conexión básica con Supabase.",
            "status": "pending",
            "testStrategy": "Verificar que variables de entorno se carguen correctamente. Probar que el cliente Supabase se inicialice sin errores. Confirmar conexión con API de Supabase mediante llamada simple.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar hook de autenticación personalizado",
            "description": "Crear hook useAuth para manejar estado de autenticación y sesiones de usuario",
            "dependencies": [
              1
            ],
            "details": "Crear hook useAuth que maneje estado de usuario (user, loading, error). Implementar funciones login, logout, y refresh token. Manejar persistencia de sesión en localStorage/secure cookies. Detectar tokens expirados y refrescar automáticamente.",
            "status": "pending",
            "testStrategy": "Probar que hook inicialice correctamente. Verificar manejo de estado de loading. Probar que se detecten tokens expirados. Confirmar que logout limpie el estado completamente.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Crear página de login con formulario seguro",
            "description": "Implementar página de login con validación CSRF y protección contra ataques",
            "dependencies": [
              1
            ],
            "details": "Crear formulario de login con email/password. Implementar validación cliente para inputs. Añadir protección CSRF con tokens únicos. Manejar errores específicos (credenciales inválidas, usuario no encontrado). Mostrar indicador de carga durante autenticación.",
            "status": "pending",
            "testStrategy": "Probar login con credenciales válidas. Intentar login con contraseña incorrecta. Verificar que errores se muestren adecuadamente. Probar que CSRF prevenga ataques. Probar validación de inputs.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implementar middleware Next.js para protección de rutas",
            "description": "Crear middleware para verificar tokens JWT y proteger rutas privadas",
            "dependencies": [
              2
            ],
            "details": "Crear middleware.ts en raíz del proyecto. Verificar tokens JWT en cookies/headers. Redirigir usuarios no autenticados a /login. Permitir acceso a rutas públicas (/login, /api/auth). Manejar token refresh automático en middleware. Configurar rutas protegidas específicas.",
            "status": "pending",
            "testStrategy": "Probar acceso a ruta protegida con token válido. Intentar acceso sin token (debe redirigir a login). Verificar que token expirado cause redirect. Probar que rutas públicas sigan accesibles.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implementar sistema de rate limiting",
            "description": "Crear sistema para limitar intentos fallidos de login por IP",
            "dependencies": [
              1
            ],
            "details": "Implementar rate limiting con Redis/memoria cache. Configurar límite de 5 intentos fallidos por IP en 15 minutos. Almacenar intentos en base de datos con timestamp. Resetear contador tras login exitoso. Mostrar mensaje específico cuando se excede límite. Configurar middleware API para rate limiting.",
            "status": "pending",
            "testStrategy": "Realizar 6 intentos fallidos desde misma IP. Verificar que 6to intento sea bloqueado. Esperar 15 minutos y probar que se resetee. Probar login exitoso resetea contador. Verificar diferentes IPs tienen contadores independientes.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Implementar logout seguro y limpieza de tokens",
            "description": "Crear sistema de logout que elimine cookies, tokens y cierre sesión correctamente",
            "dependencies": [
              2,
              4
            ],
            "details": "Implementar función logout que llame supabase.auth.signOut(). Limpiar tokens de localStorage/memory. Eliminar cookies de sesión. Invalidar tokens en backend si es necesario. Redirigir a página de login después de logout. Limpiar estado de aplicación completamente.",
            "status": "pending",
            "testStrategy": "Verificar que logout elimine todos los tokens. Probar que cookies se eliminen correctamente. Confirmar que usuario sea redirigido a login. Intentar acceder a ruta protegida después de logout (debe bloquear). Verificar que estado local se limpie.",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Configurar manejo de tokens expirados y refresh automático",
            "description": "Implementar sistema para manejar expiración de tokens y refrescarlos automáticamente",
            "dependencies": [
              2,
              4
            ],
            "details": "Configurar access tokens con expiración de 1 hora. Implementar refresh tokens con 30 días. Crear lógica para detectar tokens expirados en llamadas API. Implementar refresco automático de tokens. Manejar errores cuando refresh token también expira. Configurar timeout para tokens en memoria.",
            "status": "pending",
            "testStrategy": "Probar que access token expire después de 1 hora (simulado). Verificar que refresh automático funcione. Intentar acceso con refresh token expirado. Probar que sesión permanezca activa con refresh válido. Medir tiempo de respuesta de refresh automático.",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 7,
        "expansionPrompt": "Implementar sistema de autenticación seguro con Supabase Auth signInWithPassword. Access tokens 1 hora, refresh tokens 30 días. Rate limiting (5 intentos fallidos/IP en 15 min). Middleware Next.js para proteger rutas. CSRF protection en formularios. Logout seguro."
      },
      {
        "id": "9",
        "title": "Crear sistema de gestión de roles y permisos",
        "description": "Implementar sistema de 4 roles con permisos diferenciados según matriz RACI",
        "details": "Roles: Estudiante (básico), Moderador (aprobar/rechazar contenido), Admin (gestión completa), Superadmin (configuración sistema). Implementar verificación de permisos <50ms por request. Los estudiantes no pueden cambiar sus propios permisos. Audit log para cambios de rol",
        "testStrategy": "Crear usuarios de prueba para cada rol, verificar permisos específicos por rol, probar que estudiantes no puedan acceder a funciones de admin, y confirmar que audit log registre cambios correctamente",
        "priority": "high",
        "dependencies": [
          "5"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Diseñar esquema de base de datos para roles y permisos",
            "description": "Crear estructura de tablas en PostgreSQL para almacenar roles, permisos, asignaciones y logs de auditoría",
            "dependencies": [],
            "details": "Diseñar tabla roles (id, nombre, descripcion, nivel), tabla permisos (id, nombre, recurso, accion), tabla rol_permisos (rol_id, permiso_id), tabla usuario_roles (usuario_id, rol_id), tabla auditoria_cambios_rol (id, usuario_id, rol_anterior, rol_nuevo, timestamp, realizado_por). Crear índices para optimizar consultas <50ms",
            "status": "pending",
            "testStrategy": "Verificar estructura SQL, probar inserciones, validar relaciones y restricciones",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Definir matriz de permisos RACI por rol",
            "description": "Implementar lógica de permisos específicos según rol con matriz RACI (Responsible, Accountable, Consulted, Informed)",
            "dependencies": [
              1
            ],
            "details": "Estudiante: leer comentarios, reaccionar, notificaciones (R). Moderador: gestionar comentarios, aprobar/rechazar, ver reportes (R,A). Admin: gestión completa usuarios, contenido, configuración básica (R,A,C,I). Superadmin: configuración sistema, cambiar roles, acceso total (R,A,C,I)",
            "status": "pending",
            "testStrategy": "Crear matriz de permisos, probar cada rol con diferentes acciones",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar servicio de verificación de permisos",
            "description": "Crear middleware de verificación de permisos con respuesta <50ms usando cache en memoria",
            "dependencies": [
              1,
              2
            ],
            "details": "Implementar PermissionService con método verificarPermiso(usuarioId, recurso, accion). Usar Redis/Node.js cache para permisos activos, expiración cada 5 minutos. Log de denegaciones para auditoría. Benchmarking para garantizar <50ms respuesta. Manejo de errores y logging detallado",
            "status": "pending",
            "testStrategy": "Medir tiempo de respuesta, probar carga concurrente, validar cache effectiveness",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Crear API endpoints para gestión de roles",
            "description": "Implementar endpoints RESTful para administración de roles con validación de permisos",
            "dependencies": [
              3
            ],
            "details": "POST /api/roles (solo Superadmin), GET /api/roles (Admin+), PUT /api/roles/:id (solo Superadmin), DELETE /api/roles/:id (solo Superadmin). Validación de request body, sanitización de inputs. Rate limiting y logging. Documentación OpenAPI/Swagger",
            "status": "done",
            "testStrategy": "Probar endpoints con diferentes roles, validar restricciones de acceso",
            "parentId": "undefined",
            "updatedAt": "2025-12-01T13:07:37.646Z"
          },
          {
            "id": 5,
            "title": "Implementar sistema de asignación de roles",
            "description": "Crear funcionalidad para asignar/cambiar roles de usuarios con validaciones y auditoría",
            "dependencies": [
              4
            ],
            "details": "Sistema para cambiar roles: solo Admin puede asignar Estudiante/Moderador, solo Superadmin puede asignar Admin/Superadmin. Los estudiantes no pueden cambiar sus propios permisos (validación explícita). Transacciones atómicas. Verificación de jerarquía de roles.",
            "status": "done",
            "testStrategy": "Probar asignaciones por rol, validar que estudiantes no puedan auto-asignar roles",
            "parentId": "undefined",
            "updatedAt": "2025-12-01T13:14:59.407Z"
          },
          {
            "id": 6,
            "title": "Implementar sistema de auditoría de cambios de rol",
            "description": "Crear logging completo de cambios de rol con timestamps y trazabilidad",
            "dependencies": [
              5
            ],
            "details": "Registrar todos los cambios de rol en tabla auditoria_cambios_rol: timestamp UTC, usuario afectado, rol anterior, rol nuevo, administrador que realizó cambio, IP, user-agent. Endpoint GET /api/auditoria/roles (Admin+). Implementar búsqueda y filtros. Retención de logs por 2 años.",
            "status": "pending",
            "testStrategy": "Probar diferentes escenarios de cambios, verificar trazabilidad completa",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Crear middleware de protección de escalada de privilegios",
            "description": "Implementar validaciones para prevenir escalada de privilegios y abusos",
            "dependencies": [
              3,
              5
            ],
            "details": "Validaciones: usuarios no pueden asignarse roles superiores, Admin no puede promoverse a Superadmin, límite de cambios de rol por usuario/día, detectar patrones anómalos. Lockeo temporal tras múltiples intentos fallidos. Alertas para administradores sobre actividades sospechosas.",
            "status": "pending",
            "testStrategy": "Simular intentos de escalada, probar límites y detección de patrones",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Implementar frontend de gestión de roles",
            "description": "Crear interfaz de usuario para administración de roles con validación en cliente",
            "dependencies": [
              6,
              7
            ],
            "details": "Dashboard Admin para gestionar roles, tabla de usuarios con roles actuales, formulario de cambio de rol con validaciones, vista de auditoría con timeline, permisos visibles según rol actual. React con TypeScript, validación client-side y server-side. Toast notifications para feedback.",
            "status": "pending",
            "testStrategy": "Probar interfaz con diferentes roles, validar UX, probar responsive design",
            "parentId": "undefined"
          },
          {
            "id": 9,
            "title": "Crear tests integrales y de rendimiento",
            "description": "Implementar suite de pruebas completa para validar funcionalidad y rendimiento del sistema RBAC",
            "dependencies": [
              8
            ],
            "details": "Tests unitarios para PermissionService, endpoints API y validaciones. Tests de integración para flujo completo de gestión de roles. Tests de carga para garantizar <50ms respuesta. Tests de seguridad contra ataques de escalada de privilegios. Cobertura de código >90%. Benchmarks automatizados.",
            "status": "done",
            "testStrategy": "Ejecutar suite completa, medir cobertura, probar escenarios límite",
            "parentId": "undefined",
            "updatedAt": "2025-12-01T13:39:49.802Z"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 9,
        "expansionPrompt": "Implementar sistema RBAC con 4 roles (Estudiante, Moderador, Admin, Superadmin) y matriz de permisos diferenciada. Verificación de permisos <50ms por request. Los estudiantes no pueden cambiar sus propios permisos. Audit log para cambios de rol con timestamps.",
        "updatedAt": "2025-12-01T23:55:24.168Z"
      },
      {
        "id": "10",
        "title": "Crear perfil de usuario responsive",
        "description": "Implementar sistema de perfiles con foto, edición y configuración",
        "details": "Perfil con foto (JPG/PNG max 2MB, 200x200px) almacenada en Supabase Storage. Configuración de notificaciones guardada en <500ms. Historial de cambios visible para usuario. Formulario responsive validado con Zod. Implementar vista previa de foto antes de subir",
        "testStrategy": "Probar carga de foto con diferentes formatos y tamaños, verificar que se redimensione correctamente, probar configuración de notificaciones, y validar UX responsive en mobile y desktop",
        "priority": "medium",
        "dependencies": [
          "8",
          "9"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configurar Supabase Storage para imágenes de perfil",
            "description": "Configurar bucket de Storage en Supabase con políticas de subida y acceso para fotos de perfil de usuarios",
            "dependencies": [],
            "details": "Crear bucket 'avatars' en Supabase Storage. Configurar RLS policies para que usuarios solo puedan acceder a sus propias imágenes. Establecer tamaño máximo de 2MB y formatos JPG/PNG. Configurar URL firmadas para acceso temporal.",
            "status": "pending",
            "testStrategy": "Probar subida de archivos con diferentes formatos y tamaños, verificar políticas RLS, y confirmar acceso y eliminación de imágenes",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar validación y procesamiento de imágenes",
            "description": "Crear sistema de validación de archivos y redimensionamiento automático de imágenes a 200x200px",
            "dependencies": [
              1
            ],
            "details": "Implementar validación de formato (JPG/PNG) y tamaño máximo (2MB). Usar sharp.js para redimensionar imágenes automáticamente a 200x200px. Comprimir imágenes para optimizar tamaño. Crear sistema de vista previa antes de subida.",
            "status": "pending",
            "testStrategy": "Probar validación con formatos inválidos y archivos grandes, verificar redimensionamiento correcto, y probar compresión de diferentes tipos de imágenes",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Crear esquema de base de datos para perfiles",
            "description": "Diseñar y crear tablas para almacenar datos de perfil y configuraciones de usuario",
            "dependencies": [
              1
            ],
            "details": "Crear tabla 'profiles' con foto_url, nombre, bio, etc. Tabla 'notification_settings' para preferencias con validación de respuesta <500ms. Tabla 'profile_history' para auditoría de cambios. Configurar RLS policies para acceso por usuario.",
            "status": "pending",
            "testStrategy": "Probar inserción y actualización de datos, verificar restricciones de tipo, y confirmar políticas RLS funcionan correctamente",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Desarrollar formulario de perfil con validación Zod",
            "description": "Crear formulario responsivo para edición de perfil con validación en cliente y servidor",
            "dependencies": [
              2,
              3
            ],
            "details": "Implementar formulario con campos: nombre, bio, foto de perfil. Validación con Zod en cliente y servidor. Diseño responsivo usando Tailwind CSS. Estados de carga y errores. Previsualización de imagen antes de subida. Auto-guardado de cambios.",
            "status": "pending",
            "testStrategy": "Probar validación en cliente y servidor, verificar diseño responsivo en diferentes dispositivos, y probar flujo completo de actualización de perfil",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implementar panel de configuración de notificaciones",
            "description": "Crear interfaz para gestionar preferencias de notificaciones del usuario",
            "dependencies": [
              3
            ],
            "details": "Diseñar panel con toggles para diferentes tipos de notificaciones. Validación de respuesta <500ms para guardar cambios. Estado actual sincronizado con backend. Diseño responsivo optimizado para móvil. Indicadores de cambios no guardados.",
            "status": "pending",
            "testStrategy": "Probar tiempo de respuesta <500ms, verificar sincronización de estado, y probar funcionalidad en dispositivos móviles",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Implementar historial de cambios de perfil",
            "description": "Crear sistema para mostrar historial de modificaciones que el usuario puede consultar",
            "dependencies": [
              3,
              4
            ],
            "details": "Crear registro automático de cambios en tabla 'profile_history'. Implementar vista de historial con paginación. Mostrar quién cambió qué y cuándo. Filtros por tipo de cambio y fecha. Exportación de historial. Diseño responsivo para consulta en móvil.",
            "status": "pending",
            "testStrategy": "Probar registro automático de cambios, verificar paginación y filtros, y probar visualización en diferentes dispositivos",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 6,
        "expansionPrompt": "Implementar sistema de perfiles con foto de perfil (JPG/PNG max 2MB, 200x200px) almacenada en Supabase Storage. Configuración de notificaciones guardada en <500ms. Historial de cambios visible para usuario. Formulario responsive validado con Zod. Vista previa de foto antes de subir."
      },
      {
        "id": "11",
        "title": "Implementar editor de noticias rich-text",
        "description": "Crear editor HTML5 responsivo para contenido enriquecido de noticias",
        "details": "Implementar editor con @tiptap/react v2.1+ o similar. Soporte para imágenes embebidas (JPG, PNG, WebP max 5MB). Caracteres especiales renderizan correctamente. Tiempo de carga <2 segundos. Vista previa en tiempo real. Validación de HTML XSS sanitizado con DOMPurify",
        "testStrategy": "Probar editor en diferentes navegadores (Chrome, Firefox, Safari, Edge), verificar carga de imágenes con diferentes formatos, probar que caracteres especiales se muestren correctamente, y validar sanitización XSS",
        "priority": "high",
        "dependencies": [
          "6"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Instalar y configurar @tiptap/react v2.1+",
            "description": "Configurar el editor de texto enriquecido TipTap en el proyecto",
            "dependencies": [],
            "details": "Instalar dependencias @tiptap/react v2.1+, @tiptap/starter-kit, configurar provider del editor con extensiones básicas (Heading, Paragraph, Text, Bold, Italic, Underline)",
            "status": "pending",
            "testStrategy": "Verificar instalación correcta y renderizado inicial del editor",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar sanitización XSS con DOMPurify",
            "description": "Integrar seguridad para prevenir ataques XSS en el contenido del editor",
            "dependencies": [
              1
            ],
            "details": "Instalar DOMPurify, configurar enlace de contenido sanitizado en TipTap, implementar configuración personalizada para permitir etiquetas HTML seguras específicas para noticias",
            "status": "pending",
            "testStrategy": "Probar inyección XSS con payloads comunes y verificar sanitización efectiva",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Configurar manejo de imágenes embebidas",
            "description": "Implementar funcionalidad para insertar y gestionar imágenes en el editor",
            "dependencies": [
              1
            ],
            "details": "Crear componente Image de TipTap, configurar validación de formatos (JPG, PNG, WebP), implementar límite de tamaño 5MB, agregar UI para inserción de imágenes desde archivo o URL",
            "status": "pending",
            "testStrategy": "Probar carga de diferentes formatos y tamaños de imagen, validar rechazo de formatos no permitidos",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implementar vista previa en tiempo real",
            "description": "Crear panel de vista previa que se actualiza mientras el usuario escribe",
            "dependencies": [
              1,
              2
            ],
            "details": "Configurar useState para contenido del editor, crear componente Preview con renderizado seguro del HTML sanitizado, implementar sincronización bidireccional entre editor y vista previa",
            "status": "pending",
            "testStrategy": "Verificar actualización en tiempo real al escribir y corroborar que vista previa muestre formato correcto",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Optimizar rendimiento para carga <2 segundos",
            "description": "Asegurar rendimiento óptimo del editor y carga rápida de imágenes",
            "dependencies": [
              1,
              3
            ],
            "details": "Implementar lazy loading para imágenes, optimizar bundle con dynamic imports, configurar memoización de componentes del editor, agregar loading states para operaciones asíncronas",
            "status": "pending",
            "testStrategy": "Medir tiempo de carga del editor y rendimiento con Lighthouse para verificar <2 segundos",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Garantizar renderizado correcto de caracteres especiales",
            "description": "Asegurar compatibilidad con caracteres unicode y especiales",
            "dependencies": [
              1,
              2
            ],
            "details": "Configurar charset UTF-8 en componente, probar caracteres acentuados, símbolos especiales, emojis y caracteres de diferentes idiomas, verificar encoding correcto en guardado y recuperación",
            "status": "pending",
            "testStrategy": "Probar caracteres especiales, acentos, símbolos y emojis en diferentes navegadores",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Implementar diseño responsive y accesibilidad",
            "description": "Crear interfaz adaptable para diferentes dispositivos y accesible",
            "dependencies": [
              1,
              3
            ],
            "details": "Diseñar layout responsive con CSS Grid/Flexbox, implementar breakpoints móviles, agregar soporte para touch en dispositivos móviles, configurar navegación por teclado y ARIA labels para accesibilidad",
            "status": "pending",
            "testStrategy": "Probar en móviles, tablets y desktop, verificar navegación por teclado y screen reader compatibility",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Realizar pruebas cross-browser y validación final",
            "description": "Verificar compatibilidad completa en diferentes navegadores",
            "dependencies": [
              1,
              2,
              3,
              4,
              5,
              6,
              7
            ],
            "details": "Probar en Chrome, Firefox, Safari, Edge, verificar rendimiento y funcionalidad consistente, ejecutar pruebas automatizadas de sanitización XSS, validar carga de imágenes y caracteres especiales en todos los navegadores",
            "status": "pending",
            "testStrategy": "Testing suite completo en diferentes navegadores y dispositivos con validación de todos los requisitos",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 8,
        "expansionPrompt": "Crear editor HTML5 responsivo para contenido enriquecido de noticias con @tiptap/react v2.1+. Soporte para imágenes embebidas (JPG, PNG, WebP max 5MB). Caracteres especiales renderizan correctamente. Tiempo de carga <2 segundos. Vista previa en tiempo real. Validación XSS con DOMPurify."
      },
      {
        "id": "12",
        "title": "Implementar sistema de categorización automática",
        "description": "Crear sistema de 4 categorías automáticas para noticias",
        "details": "Categorías: Trámites, Eventos, Inscripciones, General. Cada categoría con ícono distintivo y color. Filtrado por categoría en <1 segundo usando índices PostgreSQL. Implementar UI intuitiva para selección con chips o dropdown. Responsive en mobile y desktop",
        "testStrategy": "Verificar que las 4 categorías estén disponibles, probar filtrado de noticias por categoría con tiempo de respuesta <1s, validar UI responsive en mobile, y comprobar rendimiento con 500+ artículos",
        "priority": "high",
        "dependencies": [
          "11"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Diseñar estructura de base de datos para categorías",
            "description": "Crear esquema de base de datos con tabla de categorías y sus atributos necesarios",
            "dependencies": [],
            "details": "Crear tabla categories con id, nombre, slug, icono, color, descripcion. Crear índice único en slug para queries rápidas. Modificar tabla news para añadir category_id con índice. Relacionar noticias con categorías mediante foreign key. Asegurar rendimiento para 500+ registros",
            "status": "pending",
            "testStrategy": "Verificar creación de tablas, probar índices con EXPLAIN ANALYZE, validar relaciones foreign key,测试 queries con datos de prueba",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar API backend para gestión de categorías",
            "description": "Crear endpoints CRUD para categorías con validación y filtros",
            "dependencies": [
              1
            ],
            "details": "Crear endpoints GET/POST/PUT/DELETE para categorías. Implementar validación de datos únicos. Crear endpoint de noticias filtradas por categoría. Optimizar queries con índices PostgreSQL. Añadir middleware de autenticación si necesario. Implementar rate limiting",
            "status": "pending",
            "testStrategy": "Probar CRUD operations, validar tiempo de respuesta <1s,测试 con 500+ artículos, verificar seguridad de endpoints",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Diseñar componente UI de selección de categorías",
            "description": "Crear componente responsive con chips y dropdown para filtrado",
            "dependencies": [],
            "details": "Diseñar componente CategorySelector con chips y modo dropdown. Implementar estados active/inactive para categorías. Añadir íconos distintivos y colores personalizados. Crear animaciones suaves para interacciones. Responsive design con breakpoints para mobile/tablet/desktop. Accesibilidad completa con ARIA labels",
            "status": "pending",
            "testStrategy": "Probar responsive en múltiples dispositivos, validar accesibilidad,测试 animaciones, verificar selección múltiple",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implementar sistema de filtrado en frontend",
            "description": "Integrar UI de categorías con filtrado dinámico de noticias",
            "dependencies": [
              2,
              3
            ],
            "details": "Conectar CategorySelector con API de noticias. Implementar filtrado en tiempo real con debounce de 300ms. Manejar estados de carga y error. Actualizar URL con query params para categorías seleccionadas. Implementar caché local de categorías. Optimizar render con virtualization para listas grandes",
            "status": "pending",
            "testStrategy": "Probar filtrado con 500+ artículos, verificar tiempo de respuesta <1s,测试 actualización de URL, validar caché",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Crear sistema de gestión de íconos y colores",
            "description": "Implementar sistema visual con íconos y paleta de colores para categorías",
            "dependencies": [
              1
            ],
            "details": "Definir conjunto de íconos SVG para Trámites, Eventos, Inscripciones, General. Crear paleta de colores con suficiente contraste. Implementar sistema de asignación automática de íconos/colores. Generar variantes para diferentes temas (light/dark). Optimizar SVGs para web performance. Crear sistema de fallback si ícono no disponible",
            "status": "pending",
            "testStrategy": "Probar todos los íconos en diferentes tamaños, validar contraste WCAG,测试 sistema de fallback, verificar SVG optimizados",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Implementar pruebas automatizadas y validación final",
            "description": "Crear suite de pruebas completas y validación de rendimiento",
            "dependencies": [
              4,
              5
            ],
            "details": "Crear tests unitarios para componentes y API. Implementar tests E2E con Cypress/Playwright para flujo completo. Configurar benchmarks de rendimiento con Lighthouse CI. Crear tests de carga para 500+ artículos. Validar accesibilidad con axe-automated. Implementar monitoring de métricas en producción. Crear documentación técnica",
            "status": "pending",
            "testStrategy": "Ejecutar suite completa de tests, validar Lighthouse score ≥90, probar accesibilidad, verificar métricas de rendimiento",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 6,
        "expansionPrompt": "Crear sistema de 4 categorías automáticas para noticias: Trámites, Eventos, Inscripciones, General. Cada categoría con ícono distintivo y color. Filtrado por categoría en <1 segundo usando índices PostgreSQL. UI intuitiva para selección con chips o dropdown. Responsive mobile y desktop."
      },
      {
        "id": "13",
        "title": "Implementar sistema de publicación programada",
        "description": "Crear sistema para agendar publicaciones futuras hasta 90 días",
        "details": "Calendar picker intuitivo (react-datepicker o similar). Zona horaria ART configurada correctamente. Notificación 24h antes de publicación. Máximo error de 5 minutos en ejecución. Tabla programados con trigger PostgreSQL. Validación de fechas future solo",
        "testStrategy": "Programar noticia para fecha futura y verificar que se publique automáticamente, probar notificación 24h antes, verificar manejo correcto de zona horaria ART, y comprobar precisión de ejecución (<5min)",
        "priority": "medium",
        "dependencies": [
          "11",
          "12"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configurar dependencias y librerías del calendario",
            "description": "Instalar react-datepicker y librerías de zona horaria necesarias",
            "dependencies": [],
            "details": "npm install react-datepicker date-fns-timezone date-fns @types/react-datepicker",
            "status": "pending",
            "testStrategy": "Verificar instalación correcta de dependencias y tipos TypeScript",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Crear componente CalendarPicker con zona horaria ART",
            "description": "Desarrollar componente calendario intuitivo con configuración de zona horaria Argentina",
            "dependencies": [
              1
            ],
            "details": "Componente React que utilice react-datepicker con configuración de timezone America/Argentina/Buenos_Aires, validación de fechas futuras hasta 90 días, interfaz responsive y accesible",
            "status": "pending",
            "testStrategy": "Pruebas unitarias del componente, pruebas de integración con diferentes zonas horarias, pruebas de accesibilidad con axe DevTools",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Diseñar y crear tabla de publicaciones programadas",
            "description": "Implementar estructura de base de datos para almacenar publicaciones agendadas",
            "dependencies": [],
            "details": "Tabla PostgreSQL con campos: id, contenido, fecha_programada (timestamp con timezone), estado (pending/published/completed), created_at, updated_at. Constraints para fechas futuras únicamente",
            "status": "pending",
            "testStrategy": "Pruebas de validación de esquema, pruebas de integridad de datos, pruebas de constraint de fechas futuras",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implementar trigger PostgreSQL para ejecución automática",
            "description": "Crear función trigger en PostgreSQL que ejecute publicaciones automáticamente",
            "dependencies": [
              3
            ],
            "details": "Trigger function en PostgreSQL que se active periódicamente (cada minuto) y verifique si hay publicaciones programadas para ejecutar. Manejo de errores con try-catch y logging adecuado. Precisión de ejecución con máximo 5 minutos de error",
            "status": "pending",
            "testStrategy": "Pruebas unitarias de la función trigger, pruebas de integridad temporal, pruebas de manejo de errores, pruebas de precisión de ejecución",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implementar sistema de notificaciones 24h antes",
            "description": "Crear sistema que envíe notificaciones 24 horas antes de la publicación",
            "dependencies": [
              3
            ],
            "details": "Trigger adicional que identifique publicaciones programadas para dentro de 24 horas y genere notificaciones. Integración con sistema de email o push notifications. Historial de notificaciones enviadas",
            "status": "pending",
            "testStrategy": "Pruebas de envío de notificaciones, pruebas de timing exacto (24h antes), pruebas de manejo de fallos en envío, pruebas de duplicación de notificaciones",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Crear API endpoints para gestión de programaciones",
            "description": "Desarrollar endpoints REST para crear, leer, actualizar y eliminar programaciones",
            "dependencies": [
              2,
              3
            ],
            "details": "Endpoints POST /publicaciones/programar, GET /publicaciones/programadas, PUT /publicaciones/:id, DELETE /publicaciones/:id. Validación de datos de entrada, manejo de errores, autenticación si aplica",
            "status": "pending",
            "testStrategy": "Pruebas de integración de API, pruebas de validación de datos, pruebas de seguridad, pruebas de manejo de errores HTTP",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Implementar interfaz de usuario completa del sistema",
            "description": "Crear la interfaz completa para gestión de publicaciones programadas",
            "dependencies": [
              2,
              6
            ],
            "details": "Dashboard con listado de publicaciones programadas, formulario de creación/editación con CalendarPicker, vista previa de contenido, botones de acción (editar/eliminar), indicadores de estado, manejo de loading y errores",
            "status": "pending",
            "testStrategy": "Pruebas E2E del flujo completo, pruebas de responsive design, pruebas de accesibilidad, pruebas de manejo de errores en interfaz, pruebas de performance",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 7,
        "expansionPrompt": "Crear sistema para agendar publicaciones futuras hasta 90 días. Calendar picker intuitivo (react-datepicker) con zona horaria ART configurada correctamente. Notificación 24h antes de publicación. Máximo error de 5 minutos en ejecución. Tabla programados con trigger PostgreSQL. Validación de fechas futuras solo."
      },
      {
        "id": "14",
        "title": "Implementar buscador avanzado full-text",
        "description": "Crear sistema de búsqueda con PostgreSQL full-text search",
        "details": "Búsqueda full-text en título y contenido usando PostgreSQL GIN con to_tsvector('spanish'). Filtros por categoría, rango de fechas, autor. Resultados en <500ms para base de 500+ artículos. Resaltado de términos búsqueda. Paginación optimizada. Debouncing en frontend para reducir llamadas",
        "testStrategy": "Probar búsqueda con términos simples y complejos, medir tiempo de respuesta con 500+ artículos, verificar filtros combinados funcionen correctamente, probar resaltado de términos en resultados, y validar rendimiento bajo carga",
        "priority": "high",
        "dependencies": [
          "4"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Analizar estructura de base de datos actual",
            "description": "Examinar el esquema existente de noticias y configurar PostgreSQL para búsqueda full-text",
            "dependencies": [],
            "details": "Revisar tabla de artículos existente, identificar columnas title y content, analizar tipos de datos, verificar configuración de PostgreSQL, crear columna tsvector si no existe, configurar indexación GIN para búsqueda eficiente",
            "status": "pending",
            "testStrategy": "Conectar a base de datos, ejecutar consultas básicas, verificar estructura actual",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Configurar PostgreSQL full-text search con español",
            "description": "Implementar configuración de PostgreSQL para búsqueda con configuración regional española",
            "dependencies": [
              1
            ],
            "details": "Crear configuración de texto en español con to_tsvector('spanish'), probar diferentes configuraciones de stemmer y stopwords, configurar weighting para título vs contenido, crear índices GIN optimizados",
            "status": "pending",
            "testStrategy": "Probar configuración con diferentes palabras en español, verificar resultados de stemming",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar backend API para búsqueda",
            "description": "Crear endpoints de API con filtros combinados y paginación",
            "dependencies": [
              2
            ],
            "details": "Diseñar endpoint /api/search con soporte para query string, filtros por categoría, rango de fechas, autor, implementar paginación eficiente con OFFSET/LIMIT, configurar PostgreSQL query optimizada con índices, añadir cache Redis para búsquedas frecuentes",
            "status": "pending",
            "testStrategy": "Probar API con Postman, verificar tiempos de respuesta, probar filtros combinados",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Crear interfaz de búsqueda frontend",
            "description": "Implementar UI de búsqueda con inputs dinámicos y feedback en tiempo real",
            "dependencies": [],
            "details": "Crear componente SearchForm con input principal, implementar filtros desplegables para categoría/fechas/autor, añadir botón de búsqueda, mostrar loading states, crear componentes para visualización de resultados",
            "status": "pending",
            "testStrategy": "Probar UI con diferentes tamaños de pantalla, verificar accesibilidad de inputs",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implementar highlighting de términos",
            "description": "Crear sistema para resaltar términos de búsqueda en los resultados",
            "dependencies": [
              3,
              4
            ],
            "details": "Implementar función de highlighting en backend usando ts_headline, crear componente HighlightText en frontend, configurar CSS para resaltado visual, manejar múltiples términos con diferentes colores, asegurar rendimiento con texto largo",
            "status": "pending",
            "testStrategy": "Probar highlighting con términos simples y complejos, verificar rendimiento",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Implementar debouncing y optimización frontend",
            "description": "Añadir debouncing para reducir llamadas API y mejorar UX",
            "dependencies": [
              4
            ],
            "details": "Implementar hook useDebounce para input de búsqueda, configurar tiempo de debounce (300ms), añadir loading states durante debounce, prevenir llamadas duplicadas, implementar cancelación de peticiones pendientes",
            "status": "pending",
            "testStrategy": "Probar velocidad de typing, verificar número de llamadas API, medir tiempos de respuesta",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Optimizar rendimiento y consultas",
            "description": "Ajustar configuración para lograr <500ms con 500+ artículos",
            "dependencies": [
              3
            ],
            "details": "Analizar planes de ejecución de PostgreSQL, optimizar índices GIN, configurar connection pooling, implementar query caching, añadir logging de rendimiento, ajustar límites de resultados por página, probar con dataset de prueba de 500+ artículos",
            "status": "pending",
            "testStrategy": "Cargar 500+ artículos de prueba, medir tiempos con diferentes queries, probar bajo carga",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Implementar paginación y ordenamiento",
            "description": "Crear sistema de paginación eficiente y múltiples opciones de ordenamiento",
            "dependencies": [
              3,
              7
            ],
            "details": "Implementar paginación con cursor-based para mejor rendimiento, añadir opciones de ordenamiento (relevancia, fecha, título), crear controles de paginación intuitivos, implementar scroll infinito como opción, configurar límites de página dinámicos",
            "status": "pending",
            "testStrategy": "Probar paginación con diferentes tamaños de resultados, verificar ordenamiento, probar navegación rápida",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 8,
        "expansionPrompt": "Crear sistema de búsqueda full-text en título y contenido usando PostgreSQL GIN con to_tsvector('spanish'). Filtros por categoría, rango de fechas, autor. Resultados en <500ms para base de 500+ artículos. Resaltado de términos búsqueda. Paginación optimizada. Debouncing en frontend para reducir llamadas."
      },
      {
        "id": "15",
        "title": "Implementar sistema de destacados de portada",
        "description": "Crear carrusel configurable para hasta 5 noticias principales",
        "details": "Carrusel se carga en <1 segundo con lazy loading. Cada destacado muestra thumbnail optimizado, título, descripción corta. Orden configurable mediante drag-and-drop (react-beautiful-dnd). Mobile: carrusel swipeable. Auto-rotación cada 5 segundos pausable. Transiciones suaves CSS",
        "testStrategy": "Verificar tiempo de carga <1s, probar drag-and-drop para reordenar, probar auto-rotación y pausa, validar swipe en mobile, y comprobar que thumbnails se optimicen automáticamente",
        "priority": "high",
        "dependencies": [
          "11",
          "14"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configurar estructura base del componente carrusel",
            "description": "Crear componente React base con estructura HTML semántica para el carrusel de destacados",
            "dependencies": [],
            "details": "Implementar componente CarruselDestacados con contenedor principal, track para slides, controles de navegación y estructura responsive. Usar semantic HTML5 con role attributes para accesibilidad.",
            "status": "pending",
            "testStrategy": "Verificar estructura HTML semántica, probar renderizado básico, validar accesibilidad con screen reader",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar sistema de lazy loading para thumbnails",
            "description": "Crear sistema de carga diferida para imágenes que garantice carga en menos de 1 segundo",
            "dependencies": [
              1
            ],
            "details": "Usar Intersection Observer API para detectar cuándo thumbnails entran en viewport. Implementar placeholder con skeleton loading. Optimizar imágenes con Next.js Image component y WebP format.",
            "status": "pending",
            "testStrategy": "Medir tiempo de carga <1s con Chrome DevTools, probar lazy loading con scroll, verificar placeholder animation",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Integrar react-beautiful-dnd para drag-and-drop",
            "description": "Implementar funcionalidad de reordenamiento mediante arrastrar y soltar destacados",
            "dependencies": [
              1
            ],
            "details": "Configurar react-beautiful-dnd con reorderable list. Implementar visual feedback durante drag. Guardar nuevo orden en localStorage/state. Optimizar para touch devices.",
            "status": "pending",
            "testStrategy": "Probar drag-and-drop en desktop y mobile, verificar persistencia del orden, medir rendimiento durante drag",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Desarolver carrusel swipeable para mobile",
            "description": "Implementar navegación táctil con gestos swipe para dispositivos móviles",
            "dependencies": [
              1
            ],
            "details": "Usar touch events o librería como react-swipeable. Implementar momentum scrolling. Configurar touch threshold. Añadir indicators visuales de swipe. Optimizar para iOS/Android.",
            "status": "pending",
            "testStrategy": "Probar swipe gestures en iOS/Android, verificar smoothness, medir responsividad de touch events",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implementar auto-rotación configurable",
            "description": "Crear sistema de rotación automática cada 5 segundos con opción de pausa",
            "dependencies": [
              1,
              3
            ],
            "details": "Implementar useEffect con setInterval para auto-rotación. Añadir botón de pausa/play. Detectar user interaction para pausar automáticamente. Configurar timing con options.",
            "status": "pending",
            "testStrategy": "Verificar auto-rotación cada 5s, probar pausa manual, probar auto-pausa en interacción, medir consumo de memoria",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Crear transiciones suaves con CSS",
            "description": "Implementar animaciones fluidas entre slides y para elementos interactivos",
            "dependencies": [
              1,
              2,
              3,
              4,
              5
            ],
            "details": "Usar CSS transitions y transforms para smooth animations. Implementar fade/slide effects. Optimizar con GPU acceleration. Añadir spring physics para interactions. Configurar reduced motion para accesibilidad.",
            "status": "pending",
            "testStrategy": "Verificar smoothness en diferentes dispositivos, probar reduced motion setting, medir FPS durante transiciones",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Configuración y pruebas de rendimiento final",
            "description": "Optimizar componente completo y realizar pruebas integrales de rendimiento",
            "dependencies": [
              1,
              2,
              3,
              4,
              5,
              6
            ],
            "details": "Implementar React.memo para optimización. Usar useCallback/useMemo donde sea necesario. Configurar lazy loading de componentes. Realizar bundle analysis. Medir Core Web Vitals específicos del carrusel.",
            "status": "pending",
            "testStrategy": "Medir Lighthouse score específico del carrusel, probar con datos reales, verificar accesibilidad completa, test de estrés con múltiples items",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 7,
        "expansionPrompt": "Crear carrusel configurable para hasta 5 noticias principales. Carrusel se carga en <1 segundo con lazy loading. Cada destacado muestra thumbnail optimizado, título, descripción corta. Orden configurable mediante drag-and-drop (react-beautiful-dnd). Mobile: carrusel swipeable. Auto-rotación cada 5 segundos pausable."
      },
      {
        "id": "16",
        "title": "Implementar API endpoint GET /api/news",
        "description": "Crear endpoint para listar noticias paginadas con filtros",
        "details": "Next.js API route con soporte para paginación, filtros (categorías, rango fechas, autor), ordenamiento. Usar Supabase client con select optimizado incluyendo autor y conteo de comentarios. Rate limiting 100 req/min por IP. Caching con Next.js revalidate para mejorar performance",
        "testStrategy": "Probar endpoint con diferentes combinaciones de filtros, verificar paginación funciona correctamente, medir performance bajo carga, probar rate limiting, y validar que responses incluyan datos relacionados (autor, comentarios)",
        "priority": "high",
        "dependencies": [
          "4",
          "14"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configurar estructura básica del API endpoint GET /api/news",
            "description": "Crear archivo de ruta API en Next.js con estructura inicial y endpoints básicos",
            "dependencies": [],
            "details": "Crear archivo pages/api/news.js o app/api/news/route.ts con estructura Next.js 13+ app router. Configurar CORS, headers de seguridad, y estructura básica de respuesta HTTP con status codes apropiados.",
            "status": "pending",
            "testStrategy": "Verificar que el endpoint responde con método GET, estructura JSON válida, y headers correctos",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar conexión a Supabase y queries básicas",
            "description": "Configurar cliente Supabase con joins optimizados para obtener noticias con autor y conteo de comentarios",
            "dependencies": [],
            "details": "Importar y configurar createClient de Supabase. Implementar consulta base a tabla news con LEFT JOIN a profiles para autor y COUNT para comentarios. Usar select optimizado con columns específicas.",
            "status": "pending",
            "testStrategy": "Probar conexión a Supabase, verificar que retorna datos con autor y conteo de comentarios, y validar estructura de datos",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar sistema de paginación y query parameters",
            "description": "Agregar soporte para paginación (page, limit) y filtros básicos con validación de parámetros",
            "dependencies": [
              1,
              2
            ],
            "details": "Implementar lógica de paginación con OFFSET y LIMIT de PostgreSQL. Procesar query params: page (default 1), limit (default 10, max 50). Validar tipos y rangos. Calcular total count para metadata.",
            "status": "pending",
            "testStrategy": "Probar diferentes combinaciones de page/limit, verificar responses con metadata de paginación, y testear límites máximos",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implementar filtros avanzados y ordenamiento",
            "description": "Agregar filtros por categorías, rango de fechas, autor y opciones de ordenamiento",
            "dependencies": [
              3
            ],
            "details": "Implementar filtros: category (IN), dateRange (BETWEEN), author (eq), search (ILIKE). Agregar ordenamiento por fecha, título, comentarios. Construir query dinámica con Supabase .eq(), .in(), .gte(), .lte(), .order().",
            "status": "pending",
            "testStrategy": "Probar cada filtro individualmente, combinaciones múltiples, y verificar que ordenamiento funciona correctamente",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implementar rate limiting y cache con Next.js",
            "description": "Configurar rate limiting de 100 req/min por IP y sistema de cache con revalidate",
            "dependencies": [
              4
            ],
            "details": "Implementar rate limiting con middleware o edge middleware usando storage en memoria/Redis. Configurar cache con Next.js revalidateTag() y Data Cache. Setear Cache-Control headers apropiados. Implementar key generation por query params.",
            "status": "pending",
            "testStrategy": "Probar rate limiting bajo carga, verificar cache headers, medir performance con y sin cache, y validar revalidate functionality",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Implementar manejo de errores y documentación del endpoint",
            "description": "Agregar manejo robusto de errores, validación exhaustiva y documentación completa del API",
            "dependencies": [
              5
            ],
            "details": "Implementar error handling específico: validación (400), auth (401), no encontrado (404), rate limit (429), errores server (500). Agregar logging estructurado. Crear documentación OpenAPI/Swagger con ejemplos.",
            "status": "pending",
            "testStrategy": "Probar todos los casos de error, verificar responses consistentes, testear límites de rate limiting, y validar documentación con herramientas API",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 6,
        "expansionPrompt": "Crear endpoint Next.js API route para listar noticias paginadas con soporte de filtros (categorías, rango fechas, autor) y ordenamiento. Usar Supabase client con select optimizado incluyendo autor y conteo de comentarios. Rate limiting 100 req/min por IP. Caching con Next.js revalidate para mejorar performance."
      },
      {
        "id": "17",
        "title": "Implementar API endpoint GET /api/news/:id",
        "description": "Crear endpoint para obtener detalle de noticia con comentarios jerárquicos",
        "details": "Endpoint devuelve noticia completa con autor, comentarios jerárquicos (máximo 3 niveles), reacciones. View count incrementado en cada visita. Optimización con JOINs eficientes. Respuesta en <200ms. Manejo de errores 404 para noticias no existentes. Incrementar view_count atómicamente",
        "testStrategy": "Probar con noticia existente y no existente, verificar que view_count se incremente correctamente, probar que comentarios jerárquicos se muestren anidados, medir tiempo de respuesta, y validar manejo de errores",
        "priority": "high",
        "dependencies": [
          "16"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear estructura de la base de datos y modelo para noticias con comentarios jerárquicos",
            "description": "Diseñar y crear las tablas necesarias para noticias, comentarios y reacciones, incluyendo los índices apropiados para consultas eficientes con JOINs",
            "dependencies": [],
            "details": "Crear tablas news (id, title, content, author_id, view_count, created_at, updated_at), comments (id, news_id, parent_id, user_id, content, level, created_at), reactions (id, news_id, user_id, type, created_at), users (id, name, email, avatar_url). Configurar índices en news_id para comentarios y reacciones, parent_id para jerarquía de comentarios, y author_id para autor. Implementar constraint de FKs y triggers para actualizaciones de timestamps.",
            "status": "pending",
            "testStrategy": "Crear seed data con noticias, comentarios anidados hasta 3 niveles y reacciones. Verificar integridad referencial. Probar rendimiento de consultas básicas con diferentes profundidades de comentarios.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar query SQL recursiva para comentarios jerárquicos con optimización",
            "description": "Crear consulta SQL eficiente que obtenga comentarios con estructura jerárquica hasta 3 niveles utilizando CTE recursivas y JOINs optimizados",
            "dependencies": [
              1
            ],
            "details": "Implementar consulta con CTE recursiva que limite a 3 niveles de profundidad usando WHERE level <= 3. Incluir JOINs con users para obtener datos de usuarios de comentarios y autor de noticia. Utilizar índices compuestos en (news_id, parent_id) y (news_id, created_at) para optimizar ordering. Implementar paginación opcional. La consulta debe ejecutar en <50ms para noticias con 100-200 comentarios.",
            "status": "pending",
            "testStrategy": "Probar consulta con diferentes cantidades de comentarios (10, 100, 500) y medir tiempo de ejecución. Verificar límite de 3 niveles. Probar con noticias sin comentarios.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar atomic increment de view_count con PostgreSQL",
            "description": "Crear función y mecanismo para incrementar view_count de forma atómica sin race conditions utilizando características de PostgreSQL",
            "dependencies": [
              1
            ],
            "details": "Crear función PL/pgSQL increment_news_views(news_id UUID) que utilice UPDATE news SET view_count = view_count + 1 WHERE id = news_id RETURNING view_count. Implementar mecanismo de rate limiting por IP/user para prevenir conteos fraudulentos. Configurar índice en view_count para consultas populares. Considerar usar Redis cache para conteos frecuentes con persistencia periódica a base de datos.",
            "status": "pending",
            "testStrategy": "Simular 1000 requests concurrentes a misma noticia y verificar no hay race conditions. Probar con noticias inexistentes. Medir impacto en rendimiento del incremento atómico.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Crear API route /api/news/[id] en Next.js con validación y caching",
            "description": "Implementar endpoint GET que integre todas las funcionalidades requeridas con manejo de errores robusto y optimización de respuesta",
            "dependencies": [
              2,
              3
            ],
            "details": "Crear pages/api/news/[id].js con validación de parámetro ID. Implementar try-catch para manejar errores 404, 500. Configurar revalidate ISR (incremental static regeneration) para caché de 60 segundos. Implementar headers de cache apropiados (Cache-Control: s-maxage=60, stale-while-revalidate). Incluir medición de tiempo de respuesta y logging. Utilizar PostgreSQL connection pooling.",
            "status": "pending",
            "testStrategy": "Probar endpoint con noticias existentes y no existentes. Medir tiempo de respuesta (<200ms). Verificar headers de cache correctos. Probar concurrencia de requests.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implementar formato de respuesta JSON con estructura optimizada",
            "description": "Diseñar y formatear la respuesta JSON con estructura anidada para comentarios y metadatos, optimizada para tamaño y velocidad de parsing",
            "dependencies": [
              4
            ],
            "details": "Estructurar respuesta con objeto news (id, title, content, author: {id, name, avatar_url}, view_count, created_at), comments: array anidado con replies[], reactions: array con type y count. Minimizar payload usando nombres cortos y omitiendo campos null. Implementar compression gzip. Incluir metadatos: total_comments, total_reactions, response_time_ms. Validar que respuesta total <50KB para casos típicos.",
            "status": "pending",
            "testStrategy": "Medir tamaño de respuesta para diferentes casos. Probar parsing en cliente. Verificar que todos los campos necesarios estén presentes. Probar con respuesta vacía (sin comentarios).",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Implementar manejo específico de errores y logging",
            "description": "Crear sistema robusto de manejo de errores con logging estructurado para debugging y monitoring",
            "dependencies": [
              5
            ],
            "details": "Implementar error handling específico: 404 para noticia no encontrada con mensaje 'Noticia no encontrada', 500 para errores internos con 'Error interno del servidor'. Incluir logging estructurado con request_id, ip_address, user_agent, news_id, error_details, timestamp. Configurar diferentes niveles de log (error, warn, info). Implementar rate limiting por IP para prevenir abuso. Incluir CORS headers apropiados.",
            "status": "pending",
            "testStrategy": "Probar todos los casos de error intencionalmente. Verificar que mensajes sean apropiados para cada código de estado. Probar que logging capture información necesaria. Verificar rate limiting funciona.",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Crear suite de tests integrales y de rendimiento",
            "description": "Desarrollar tests completos que validen funcionalidad, rendimiento y manejo de errores del endpoint",
            "dependencies": [
              6
            ],
            "details": "Crear tests con Jest y Supertest para: respuesta exitosa con todos los datos, respuesta 404 correcta, incremento de view_count, estructura de comentarios jerárquicos, límite de 3 niveles, tiempo de respuesta <200ms, manejo de concurrencia, validación de formato JSON. Incluir tests de carga con Artillery para 100 requests concurrentes. Implementar tests de regresión para asegurar <200ms en diferentes escenarios de carga.",
            "status": "pending",
            "testStrategy": "Ejecutar todos los tests unitarios y de integración. Correr tests de carga y medir métricas. Verificar que view_count se incremente correctamente. Probar con diferentes profundidades de comentarios.",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 7,
        "expansionPrompt": "Crear endpoint Next.js API route para obtener detalle de noticia con comentarios jerárquicos (máximo 3 niveles) y reacciones. View count incrementado atómicamente en cada visita. Optimización con JOINs eficientes. Respuesta en <200ms. Manejo de errores 404 para noticias no existentes."
      },
      {
        "id": "18",
        "title": "Implementar API endpoint POST /api/news",
        "description": "Crear endpoint para crear nuevas noticias (solo admin)",
        "details": "Endpoint protegido para roles admin+. Validación con Zod: title, content, category (enum), author_id. Sanitización HTML con DOMPurify. Procesamiento de imágenes (upload a Supabase Storage, compresión automática). Respuesta con noticia creada. Transaction atómica en base de datos",
        "testStrategy": "Probar creación con datos válidos como admin, intentar crear como estudiante (debe fallar), probar con datos inválidos, verificar sanitización HTML, y probar upload de imágenes",
        "priority": "high",
        "dependencies": [
          "5",
          "11"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configurar middleware de autenticación por rol",
            "description": "Implementar middleware para verificar que solo usuarios con rol admin+ puedan acceder al endpoint POST /api/news",
            "dependencies": [],
            "details": "Crear middleware Next.js que verifique el rol del usuario en el token JWT. El middleware debe devolver error 401 para no autenticados y 403 para roles insuficientes. Integrar con la estrategia de autenticación existente del proyecto.",
            "status": "pending",
            "testStrategy": "Probar acceso con token de admin (200), con token de estudiante (403), sin token (401), y con token inválido (401)",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Definir esquema de validación Zod",
            "description": "Crear esquema Zod para validar los datos de entrada del endpoint POST /api/news",
            "dependencies": [],
            "details": "Implementar esquema Zod con validación estricta para: title (string min 3, max 200), content (string min 10, max 5000), category (enum: política, economía, deportes, tecnología, cultura), author_id (número entero positivo). Incluir mensajes de error en español y validación personalizada.",
            "status": "pending",
            "testStrategy": "Probar datos válidos, título vacío, título demasiado largo, categoría inválida, content vacío, author_id negativo, y tipos incorrectos",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Integrar sanitización HTML con DOMPurify",
            "description": "Implementar sanitización de contenido HTML para prevenir ataques XSS en el campo content",
            "dependencies": [],
            "details": "Configurar DOMPurify con opciones seguras: ALLOWED_TAGS básicas (p, h1-h6, strong, em, ul, li, blockquote), ALLOWED_ATTR seguros, y conservar formato básico. Crear función sanitizarHTML(content) que aplique DOMPurify y retorne el HTML sanitizado.",
            "status": "pending",
            "testStrategy": "Probar con scripts maliciosos (deben eliminarse), HTML válido (debe conservarse), atributos peligrosos (deben eliminarse), y contenido normal (debe pasar)",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implementar procesamiento y compresión de imágenes",
            "description": "Crear sistema para subir imágenes a Supabase Storage con compresión automática",
            "dependencies": [],
            "details": "Implementar función para procesar imágenes: Validar formato (jpg, png, webp), validar tamaño máximo (5MB), redimensionar automáticamente a 1200x630 para Open Graph, comprimir con calidad 80%, generar thumbnails 300x200, y subir a bucket 'news-images' en Supabase Storage.",
            "status": "pending",
            "testStrategy": "Probar con imágenes válidas (deben procesarse y subirse), formatos inválidos (rechazarse), imágenes grandes (deben comprimirse), y sin imagen (endpoint debe funcionar)",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Crear API route POST /api/news",
            "description": "Implementar el endpoint principal que integra toda la funcionalidad",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Crear archivo pages/api/news.js o app/api/news/route.js que combine: middleware de autenticación, validación Zod, procesamiento de imágenes, sanitización HTML, inserción en base de datos con Transactor Supabase, y respuesta JSON con noticia creada incluyendo URLs de imágenes procesadas.",
            "status": "pending",
            "testStrategy": "Probar flujo completo con datos válidos, datos inválidos (400), sin permisos (403), conexión a base de datos, y respuesta correcta con noticia creada",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Configurar transacción atómica en base de datos",
            "description": "Implementar transacción SQL atómica para garantizar consistencia de datos",
            "dependencies": [],
            "details": "Usar Supabase RPC o SQL transaction para: 1) Insertar noticia en tabla news, 2) Actualizar conteo de noticias del autor, 3) Registrar imágenes en news_images si aplica, 4) Hacer rollback automático en caso de error. Incluir try-catch con rollback manual como fallback.",
            "status": "pending",
            "testStrategy": "Probar inserción exitosa, error en insertar (rollback completo), error en insertar imagen (rollback de noticia), y concurrencia de múltiples solicitudes",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Implementar response formatting y error handling",
            "description": "Crear respuestas estandarizadas y manejo centralizado de errores",
            "dependencies": [
              5,
              6
            ],
            "details": "Implementar formato de respuesta estándar: { success: boolean, data: noticia | null, error: string | null, message: string }. Manejar tipos específicos de errores: ValidationError (400), AuthError (401/403), DatabaseError (500), ImageProcessingError (400). Incluir logging de errores con contexto.",
            "status": "pending",
            "testStrategy": "Probar respuesta exitosa (200 con noticia), validación fallida (400 con mensaje), auth fallida (401/403), error de base de datos (500), y verificar estructura JSON consistente",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 7,
        "expansionPrompt": "Crear endpoint Next.js API route protegido para roles admin+. Validación con Zod: title, content, category (enum), author_id. Sanitización HTML con DOMPurify. Procesamiento de imágenes (upload a Supabase Storage, compresión automática). Respuesta con noticia creada. Transaction atómica en base de datos."
      },
      {
        "id": "19",
        "title": "Implementar sistema de tópicos y comentarios jerárquicos",
        "description": "Crear sistema de foro con anidamiento hasta 3 niveles",
        "details": "UI clara mostrando relación padre-hijo con indentación visual. Máximo 3 niveles de profundidad. Creación de tópicos en <30 segundos. Almacenamiento en Supabase con parent_comment_id FK. Lazy loading para comentarios largos. Avatares de usuarios responsive. Timestamps relativos ('hace 2 horas')",
        "testStrategy": "Probar creación de tópicos y comentarios con diferentes niveles de anidamiento, verificar que UI muestre jerarquía claramente, medir tiempo de creación (<30s), y probar comportamiento responsive en mobile",
        "priority": "high",
        "dependencies": [
          "4",
          "17"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Diseñar esquema de base de datos en Supabase",
            "description": "Crear estructura de tablas para sistema de comentarios jerárquicos con hasta 3 niveles de anidamiento",
            "dependencies": [],
            "details": "Diseñar tabla comments con id, content, parent_comment_id (FK), topic_id, created_at, updated_at. Crear tabla topics con id, title, slug, created_at. Configurar índices para performance en parent_comment_id y created_at. Establecer constraints para máximo 3 niveles con triggers o a nivel de aplicación.",
            "status": "pending",
            "testStrategy": "Validar esquema con migraciones, probar FK constraints, verificar índices con consultas EXPLAIN",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar backend API para tópicos",
            "description": "Crear endpoints CRUD para gestión de tópicos con validación y optimización",
            "dependencies": [],
            "details": "Implementar POST /api/topics para crear tópicos en <30 segundos. GET /api/topics para listar tópicos con paginación. PUT /api/topics/:id para actualizar. DELETE /api/topics/:id para eliminar. Configurar middleware de autenticación y validación de input con sanitización de HTML.",
            "status": "pending",
            "testStrategy": "Unit tests para cada endpoint, pruebas de carga para <30s creación, pruebas de seguridad SQL injection",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Desarrollar backend API para comentarios jerárquicos",
            "description": "Crear sistema de comentarios con soporte para hasta 3 niveles de anidamiento",
            "dependencies": [],
            "details": "Implementar POST /api/comments para crear comentarios con parent_comment_id. GET /api/comments/topic/:topicId con lazy loading para comentarios hijos. GET /api/comments/:id para comentario individual. PUT y DELETE con validación de permisos. Implementar cálculo de profundidad y validación de máximo 3 niveles.",
            "status": "pending",
            "testStrategy": "Probar creación de comentarios en diferentes niveles, validar límite de 3 niveles, probar lazy loading con datasets grandes",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Crear componente UI para tópicos",
            "description": "Diseñar interfaz responsive para crear y visualizar tópicos",
            "dependencies": [],
            "details": "Desarrollar componente TopicForm con validación de <30 segundos creación. Componente TopicList con loading states. Implementar estilos responsive con mobile-first design. Usar React Hook Form para manejo eficiente de formularios. Configurar skeleton loaders durante carga.",
            "status": "pending",
            "testStrategy": "Pruebas visuales responsive en diferentes tamaños, medir tiempo de creación <30s, pruebas de accesibilidad",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implementar componente de comentarios jerárquicos",
            "description": "Crear interfaz visual que muestre relación padre-hijo con indentación clara",
            "dependencies": [
              4
            ],
            "details": "Desarrollar CommentList con renderizado recursivo limitado a 3 niveles. Implementar indentación visual con CSS márgenes. Crear CommentForm para respuestas rápidas. Configurar lazy loading para comentarios grandes con botón \"Cargar más\". Implementar collapse/expand para sub-hilos de comentarios.",
            "status": "pending",
            "testStrategy": "Probar renderizado de 3 niveles máximo, validar indentación visual, probar lazy loading con 1000+ comentarios",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Implementar sistema de timestamps relativos",
            "description": "Crear utilidad para mostrar fechas en formato relativo ('hace 2 horas')",
            "dependencies": [],
            "details": "Desarrollar hook useRelativeTime que formatee timestamps relativos en español. Implementar actualización automática cada minuto para comentarios recientes. Crear tooltip con timestamp exacto. Considerar timezone del usuario. Optimizar para no re-renderizar componentes innecesariamente.",
            "status": "pending",
            "testStrategy": "Probar diferentes formatos de tiempo, validar actualizaciones automáticas, pruebas de performance con múltiples timestamps",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Crear sistema de avatares responsive",
            "description": "Implementar visualización de usuarios con avatares optimizados para diferentes tamaños",
            "dependencies": [],
            "details": "Desarrollar componente Avatar con diferentes tamaños (xs, sm, md, lg, xl). Implementar lazy loading para imágenes de avatar. Configurar placeholders con iniciales de usuario. Soportar avatares por defecto con gradientes. Optimizar para mobile con tamaños adaptativos según viewport.",
            "status": "pending",
            "testStrategy": "Pruebas responsive en mobile/tablet/desktop, medir rendimiento de carga de imágenes, probar fallback con iniciales",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Implementar validación y seguridad en frontend",
            "description": "Agregar validaciones de seguridad y límites en el lado del cliente",
            "dependencies": [
              4,
              5
            ],
            "details": "Implementar validación de longitud máxima para comentarios. Protección contra XSS con sanitización. Debounce para prevención de envíos duplicados. Validar límite de 3 niveles de anidamiento en UI. Implementar rate limiting visual con botón deshabilitado temporalmente.",
            "status": "pending",
            "testStrategy": "Pruebas de seguridad XSS, probar límite de caracteres, validar prevención de envíos duplicados, tests de límite de niveles",
            "parentId": "undefined"
          },
          {
            "id": 9,
            "title": "Optimizar performance y lazy loading avanzado",
            "description": "Implementar optimizaciones para handling de grandes volúmenes de comentarios",
            "dependencies": [
              5,
              6,
              7
            ],
            "details": "Implementar virtual scrolling para listas largas de comentarios. Configurar Intersection Observer para lazy loading de imágenes y comentarios. Agregar memoización con React.memo para componentes estáticos. Implementar prefetching en hover. Configurar skeleton screens diferidos. Optimizar bundle con dynamic imports.",
            "status": "pending",
            "testStrategy": "Pruebas de performance con 10k+ comentarios, medir Lighthouse scores, probar memory usage, validar lazy loading",
            "parentId": "undefined"
          },
          {
            "id": 10,
            "title": "Configurar testing end-to-end y validación completa",
            "description": "Crear suite de pruebas E2E que valide el flujo completo del sistema",
            "dependencies": [
              1,
              2,
              3,
              4,
              5,
              6,
              7,
              8,
              9
            ],
            "details": "Implementar tests E2E con Playwright/Cypress para flujo completo: crear tópico, agregar comentarios de 3 niveles, verificar UI responsive, probar timestamps relativos, validar creación <30s. Configurar Visual Regression Testing. Agregar pruebas de accesibilidad completas. Implementar tests de carga con herramientas como k6.",
            "status": "pending",
            "testStrategy": "Ejecutar suite completa E2E, pruebas visuales de UI, tests de accesibilidad WCAG, pruebas de carga con múltiples usuarios",
            "parentId": "undefined"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 10,
        "expansionPrompt": "Crear sistema de foro con anidamiento hasta 3 niveles. UI clara mostrando relación padre-hijo con indentación visual. Máximo 3 niveles de profundidad. Creación de tópicos en <30 segundos. Almacenamiento en Supabase con parent_comment_id FK. Lazy loading para comentarios largos. Avatares de usuarios responsive. Timestamps relativos."
      },
      {
        "id": "20",
        "title": "Implementar sistema de reacciones con emojis",
        "description": "Crear sistema para reaccionar con emojis a comentarios",
        "details": "Reacciones disponibles: 👍, ❤️, 😂, 🤔, 😢. Máximo 1 reacción por usuario por comentario (UNIQUE constraint). Contador actualizado en tiempo real con Supabase realtime. Hover muestra lista de usuarios que reaccionaron. Mobile: tap para seleccionar reacción. Queries optimizadas",
        "testStrategy": "Probar diferentes reacciones en múltiples comentarios, verificar UNIQUE constraint funcionando, probar actualización en tiempo real, probar hover en desktop y tap en mobile, y medir performance bajo carga",
        "priority": "high",
        "dependencies": [
          "19"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Analizar sistema actual de comentarios y estructura de base de datos",
            "description": "Examinar la estructura existente de comentarios en Supabase para entender cómo integrar el sistema de reacciones sin afectar la funcionalidad actual",
            "dependencies": [],
            "details": "Revisar tabla comments actual, identificar tipos de datos existentes, analizar relaciones con usuarios, y determinar la mejor estrategia para añadir reacciones sin modificar la estructura existente de comments",
            "status": "pending",
            "testStrategy": "Verificar que sistema de comentarios existente continúe funcionando después de análisis, documentar estructura actual, y validar compatibilidad con nuevo sistema de reacciones",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Diseñar tabla reactions en Supabase con constraint UNIQUE",
            "description": "Crear la tabla de base de datos para almacenar reacciones con la constraint UNIQUE que garantice máximo una reacción por usuario por comentario",
            "dependencies": [
              1
            ],
            "details": "Diseñar tabla con campos: id (SERIAL), comment_id (FK), user_id (FK), emoji_type (VARCHAR/ENUM), created_at (TIMESTAMP), updated_at (TIMESTAMP). Implementar constraint UNIQUE compuesta (comment_id, user_id) para evitar múltiples reacciones del mismo usuario",
            "status": "pending",
            "testStrategy": "Probar inserción de múltiples reacciones del mismo usuario (debe fallar), probar reacciones válidas de diferentes usuarios, verificar constraint UNIQUE funcionando, y testear rollback transaccional",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Configurar Supabase Realtime para actualizaciones en vivo",
            "description": "Implementar suscripción a Supabase Realtime para que los contadores de reacciones se actualicen automáticamente en tiempo real para todos los clientes conectados",
            "dependencies": [
              2
            ],
            "details": "Configurar RLS policies para tabla reactions, suscribirse a cambios INSERT/UPDATE/DELETE, implementar filtros específicos para comment_id, y manejar desconexiones/reconexiones automáticas con strategy de re-suscripción",
            "status": "pending",
            "testStrategy": "Probar actualizaciones simultáneas desde múltiples clientes, verificar que contadores se actualicen inmediatamente, testear re-conexión después de desconexión, y medir latencia de actualizaciones",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implementar API endpoints para gestionar reacciones",
            "description": "Crear funciones del servidor para añadir, eliminar y obtener reacciones con validación de constraint UNIQUE y manejo de errores apropiado",
            "dependencies": [
              2,
              3
            ],
            "details": "Implementar POST /api/reactions (toggle reaction), GET /api/reactions/:commentId, DELETE /api/reactions/:commentId/:emoji, middleware de autenticación, validación de inputs, y manejo de errores específicos con códigos HTTP apropiados",
            "status": "pending",
            "testStrategy": "Testear toggle de reacción (add/remove), probar request sin autenticación (debe fallar), verificar constraint UNIQUE en API, probar rate limiting, y testear casos edge con comentarios inexistentes",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Crear componente UI de selector de emojis (desktop y mobile)",
            "description": "Desarrollar componente interactivo para seleccionar emojis con diferentes comportamientos para desktop (hover) y mobile (tap)",
            "dependencies": [
              4
            ],
            "details": "Crear componente ReactionButton con estado hover/tap, detectar dispositivo mediante media queries o user agent, implementar debounce para evitar múltiples clicks, y usar React hooks para manejar estado local sincronizado con servidor",
            "status": "pending",
            "testStrategy": "Probar comportamiento en desktop (hover muestra opciones), probar en mobile (tap abre/cierra selector), testear responsive design, verificar accesibilidad por teclado, y medir performance con múltiples comentarios",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Implementar contador de reacciones con actualización en tiempo real",
            "description": "Crear componente que muestre el contador total de cada tipo de reacción y se actualice automáticamente cuando cambian las reacciones",
            "dependencies": [
              3,
              5
            ],
            "details": "Implementar hook useReactions(commentId) con suscripción Realtime, contar reacciones por tipo (emoji), memorizar resultados para evitar re-renders innecesarios, y sincronizar estado local con cambios remotos via Supabase Realtime",
            "status": "pending",
            "testStrategy": "Verificar contador se actualice al añadir/quitar reacciones, probar múltiples usuarios reaccionando simultáneamente, testear persistencia al recargar página, y validar que contador refleje estado correcto del servidor",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Desarrollar tooltip/hover para mostrar lista de usuarios que reaccionaron",
            "description": "Implementar componente que al hacer hover sobre el contador muestre la lista de usuarios que han reaccionado con cada emoji",
            "dependencies": [
              6
            ],
            "details": "Crear ReactionTooltip con información de usuarios, implementar query optimizada para obtener usernames y avatares, usar portal React para correcto z-index, configurar delay para hover (show después de 300ms), y manejar scroll dentro del tooltip si hay muchos usuarios",
            "status": "pending",
            "testStrategy": "Probar tooltip con múltiples usuarios, verificar posición correcta cerca del contador, testear comportamiento en mobile (tap en lugar de hover), probar scroll interno con lista larga, y validar rendimiento con tooltips múltiples en página",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Optimizar queries y manejar casos edge con manejo de errores",
            "description": "Optimizar el rendimiento del sistema de reacciones con queries eficientes y manejo robusto de errores y casos límite",
            "dependencies": [
              7
            ],
            "details": "Implementar batch queries para obtener reacciones de múltiples comentarios, añadir índices database para performance optimizada, configurar cache React Query para reacciones frecuentes, implementar fallback UI para errores de red, y agregar loading states apropiados para mejor UX",
            "status": "pending",
            "testStrategy": "Medir rendimiento con 100+ comentarios en pantalla, probar comportamiento offline, testear recuperación de errores de red, verificar cache invalidation correcta, y stress test con 1000+ reacciones simultáneas",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 8,
        "expansionPrompt": "Crear sistema para reaccionar con emojis (👍, ❤️, 😂, 🤔, 😢) a comentarios. Máximo 1 reacción por usuario por comentario (UNIQUE constraint). Contador actualizado en tiempo real con Supabase realtime. Hover muestra lista de usuarios que reaccionaron. Mobile: tap para seleccionar reacción. Queries optimizadas."
      },
      {
        "id": "21",
        "title": "Implementar sistema de notificaciones de respuestas",
        "description": "Crear sistema de notificaciones para respuestas a comentarios",
        "details": "Notificación en-app dentro de 5 segundos cuando alguien responde. Opción de deshabilitar por tópico. Link en notificación lleva directamente al comentario. Máximo 1 notificación consolidada por tópico/hora. Implementar con Supabase Realtime para actualizaciones instantáneas",
        "testStrategy": "Probar que notificaciones lleguen en <5s, probar consolidación de múltiples notificaciones, verificar link directo al comentario, probar deshabilitación por tópico, y validar rendimiento con múltiples usuarios activos",
        "priority": "medium",
        "dependencies": [
          "19",
          "20"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configurar base de datos de notificaciones en Supabase",
            "description": "Crear tablas necesarias y configurar sistema de base de datos para almacenar notificaciones y preferencias de usuario",
            "dependencies": [],
            "details": "Crear tabla 'notifications' con campos: id, user_id, comment_id, topic_id, notification_type, created_at, read_at, consolidated_group. Tabla 'notification_preferences' con user_id, topic_id, enabled (default true), notification_types[]",
            "status": "pending",
            "testStrategy": "Verificar creación de tablas, probar inserciones de datos, validar relaciones foreign keys y probar índices de rendimiento",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar suscripción a Supabase Realtime",
            "description": "Configurar cliente Supabase con suscripción en tiempo real para detectar nuevas respuestas a comentarios",
            "dependencies": [
              1
            ],
            "details": "Configurar SupabaseClient en frontend, implementar canal realtime para tabla 'comments' filtrando por respuestas (parent_id != null), manejar re-conexiones automáticas",
            "status": "pending",
            "testStrategy": "Probar detección de nuevas respuestas en <5 segundos, verificar manejo de desconexiones, probar múltiples tabs abiertos simultáneamente",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Crear sistema de consolidación de notificaciones",
            "description": "Implementar lógica para agrupar notificaciones del mismo tópico dentro de una ventana de 1 hora",
            "dependencies": [
              2
            ],
            "details": "Crear lógica client-side para verificar notificaciones existentes del mismo tópico en última hora, mantener registro de última notificación por tópico, actualizar contador en lugar de crear nueva notificación",
            "status": "pending",
            "testStrategy": "Probar consolidación con múltiples respuestas rápidas, verificar que máx 1 notificación/hora por tópico, probar con diferentes usuarios y tópicos",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implementar componente UI de notificaciones",
            "description": "Crear componente de notificaciones en-app con diseño no intrusivo y animaciones suaves",
            "dependencies": [
              3
            ],
            "details": "Componente NotificationToast con slide-in desde top-right, icono de comentario, texto compacto, botón de cerrar, auto-hide después de 5 segundos, manejo de hover para mantener visible",
            "status": "pending",
            "testStrategy": "Probar animaciones en diferentes tamaños de pantalla, verificar accesibilidad por teclado, probar auto-hide y hover, probar múltiples notificaciones apiladas",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implementar navegación directa y preferencias",
            "description": "Agregar enlaces directos al comentario y sistema de deshabilitación por tópico para notificaciones",
            "dependencies": [
              4
            ],
            "details": "Link en notificación que lleva directamente al comentario con scroll automático, opción de deshabilitar notificaciones por tópico en configuración, checkbox por cada tópico en perfil de usuario",
            "status": "pending",
            "testStrategy": "Probar navegación directa con diferentes posiciones de comentario, verificar configuración por tópico, probar persistencia de preferencias, probar enable/disable en tiempo real",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Implementar estado de leído y contadores",
            "description": "Sistema para marcar notificaciones como leídas y mantener contadores de notificaciones no leídas",
            "dependencies": [
              5
            ],
            "details": "Update en base de datos al hacer click en notificación (read_at = NOW()), badge con contador de notificaciones no leídas, sync automático del contador, histórico de notificaciones leídas",
            "status": "pending",
            "testStrategy": "Probar actualización de estado leído en múltiples dispositivos, verificar badge contador, probar persistencia de estado, probar sincronización cross-tab",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 6,
        "expansionPrompt": "Crear sistema de notificaciones para respuestas a comentarios con Supabase Realtime. Notificación en-app dentro de 5 segundos cuando alguien responde. Opción de deshabilitar por tópico. Link en notificación lleva directamente al comentario. Máximo 1 notificación consolidada por tópico/hora."
      },
      {
        "id": "22",
        "title": "Implementar sistema de moderación básica",
        "description": "Crear sistema para moderadores editar/eliminar comentarios",
        "details": "Moderadores pueden editar/eliminar comentarios inapropiados con registro de auditoría. Edición/eliminación toma <1 segundo. Historial de cambios visible para moderadores. Notificación automática al usuario eliminado explicando razón. Comentarios eliminados muestran '[Comentario eliminado por moderación]'",
        "testStrategy": "Probar edición y eliminación como moderador, verificar que estudiantes no puedan moderar, probar audit log, confirmar notificación al usuario, y validar tiempo de respuesta <1s",
        "priority": "high",
        "dependencies": [
          "19",
          "9"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear modelo de base de datos para auditoría de moderación",
            "description": "Diseñar e implementar estructura de tablas para tracking de acciones de moderadores",
            "dependencies": [],
            "details": "Crear tablas: moderation_log (id, comment_id, moderator_id, action, old_content, new_content, timestamp, reason), moderation_actions (id, name, description), moderation_notifications (id, user_id, moderation_id, sent, timestamp). Agregar índices para queries rápidas y asegurar operaciones sub-1 segundo",
            "status": "pending",
            "testStrategy": "Probar creación de tablas, verificar constraints de integridad, test de rendimiento con 1000+ registros, validar índices optimizados",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar middleware de autorización para roles de moderador",
            "description": "Crear sistema de autenticación que verifique permisos de moderador",
            "dependencies": [],
            "details": "Implementar middleware next-auth o similar con roles (admin, moderator, user). Crear funciones helper: isModerator(), isAdmin(), canModerateComments(). Integrar con sistema de usuarios existente. Agregar endpoint para verificar rol actual",
            "status": "pending",
            "testStrategy": "Probar acceso denegado para usuarios regulares, verificar acceso permitido para moderadores, test de bypass intentado, validar rendimiento <1s",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Desarrollar API endpoints para acciones de moderación",
            "description": "Crear endpoints REST para editar y eliminar comentarios con auditoría",
            "dependencies": [
              1,
              2
            ],
            "details": "POST /api/moderate/comments/:id/edit (con razón obligatoria), DELETE /api/moderate/comments/:id (con razón obligatoria), GET /api/moderate/comments/:id/history. Cada acción debe registrar en moderation_log y retornar respuesta <1s. Validar razón mínima 10 caracteres",
            "status": "pending",
            "testStrategy": "Probar edición exitosa con registro, test eliminación con placeholder, validar historial de cambios, medir tiempo respuesta <1s",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Crear componente UI para moderadores en dashboard",
            "description": "Desarrollar interfaz visual para que moderadores gestionen comentarios",
            "dependencies": [
              2
            ],
            "details": "Crear CommentModeratorPanel con lista de comentarios reportados/inapropiados. Botones para editar/eliminar con modal de razón. Historial de cambios expandido. Vista previa de ediciones en tiempo real. Indicadores de acción requerida",
            "status": "pending",
            "testStrategy": "Probar renderizado de panel, test modal de razón, verificar historial expandido, validar UX para acciones rápidas",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implementar sistema de notificaciones automáticas",
            "description": "Crear sistema que notifique a usuarios cuando sus comentarios son moderados",
            "dependencies": [
              1,
              3
            ],
            "details": "Implementar servicio NotificationService con plantillas email/ push: comentario_editado, comentario_eliminado. Integrar con SendGrid o similar. Sistema colas para procesamiento asíncrono. Personalización con nombre y razón específica",
            "status": "pending",
            "testStrategy": "Probar envío email edición, test notificación eliminación, verificar personalización, validar plantillas en español",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Crear sistema de placeholder para comentarios eliminados",
            "description": "Implementar visualización cuando comentarios son eliminados por moderación",
            "dependencies": [
              3,
              4
            ],
            "details": "Crear CommentPlaceholder component con texto '[Comentario eliminado por moderación]'. Mostrar razón si es usuario autor del comentario. Para otros usuarios mostrar mensaje genérico. Integrar con sistema de comentarios existente",
            "status": "pending",
            "testStrategy": "Probar placeholder para autor, test placeholder para otros usuarios, verificar display correcto, validar consistencia UI",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Implementar dashboard de auditoría para administradores",
            "description": "Crear panel administrativo para revisar acciones de moderación",
            "dependencies": [
              1,
              3,
              5
            ],
            "details": "Crear ModerationAuditDashboard con tabla de todas las acciones de moderación. Filtros por moderador, fecha, tipo acción. Estadísticas básicas (acciones/día, moderadores más activos). Exportación CSV de logs. Vista detallada de cada acción con razón completa",
            "status": "pending",
            "testStrategy": "Probar filtros funcionan, test exportación CSV, verificar estadísticas, validar rendimiento con grandes volúmenes",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 7,
        "expansionPrompt": "Crear sistema para moderadores editar/eliminar comentarios inapropiados con registro de auditoría. Edición/eliminación toma <1 segundo. Historial de cambios visible para moderadores. Notificación automática al usuario eliminado explicando razón. Comentarios eliminados muestran '[Comentario eliminado por moderación]'."
      },
      {
        "id": "23",
        "title": "Implementar sistema de reportes de contenido",
        "description": "Crear sistema para que estudiantes reporten comentarios inapropiados",
        "details": "Categorías de reporte: Spam, Acoso, Contenido Inapropiado, Otro. Máximo 1 reporte por usuario por comentario. Dashboard para moderadores mostrando reportes pendientes con prioridad por cantidad de reportes. Automatización threshold para auto-eliminar con múltiples reportes",
        "testStrategy": "Probar reporte de comentario con diferentes categorías, verificar límite de 1 reporte por usuario, probar dashboard de moderadores, y validar umbral de auto-eliminación",
        "priority": "medium",
        "dependencies": [
          "22"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Diseñar y crear esquema de base de datos para reportes",
            "description": "Crear tablas para almacenar reportes de comentarios con categorías, usuarios y estado",
            "dependencies": [],
            "details": "Diseñar tablas: reports (id, user_id, comment_id, category_id, description, status, created_at), report_categories (id, name), report_status (pending, reviewed, resolved). Implementar constraint UNIQUE para evitar múltiples reportes del mismo usuario al mismo comentario",
            "status": "pending",
            "testStrategy": "Crear migraciones y probar que previene reportes duplicados del mismo usuario",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar API endpoints para sistema de reportes",
            "description": "Crear endpoints para crear, consultar y gestionar reportes de contenido",
            "dependencies": [
              1
            ],
            "details": "Implementar POST /api/reports para crear nuevo reporte con validación de usuario único por comentario, GET /api/reports para moderadores, PUT /api/reports/:id para actualizar estado, DELETE /api/comments/:id para eliminación automática",
            "status": "pending",
            "testStrategy": "Probar endpoints con diferentes roles de usuario, validar límite de 1 reporte por usuario",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Desarrollar UI de reportes para usuarios",
            "description": "Crear componente de reporte en comentarios y confirmación visual",
            "dependencies": [
              2
            ],
            "details": "Botón de reporte en cada comentario con modal de selección de categoría (Spam, Acoso, Contenido Inapropiado, Otro), campo de descripción opcional, confirmación y feedback visual de reporte exitoso",
            "status": "pending",
            "testStrategy": "Probar flujo completo de reporte desde botón hasta confirmación, verificar categorías funcionan",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Construir dashboard de moderación de reportes",
            "description": "Crear interfaz para moderadores con priorización automática por cantidad de reportes",
            "dependencies": [
              2
            ],
            "details": "Dashboard con tabla de reportes pendientes ordenados por cantidad de reportes (mayor cantidad arriba), filtros por categoría y estado, vista detallada de cada reporte con comentario original y acciones rápidas",
            "status": "pending",
            "testStrategy": "Probar que reportes con múltiples denuncias aparezcan primero, verificar filtros funcionan correctamente",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implementar sistema de automatización y thresholds",
            "description": "Crear sistema para auto-eliminar comentarios con múltiples reportes",
            "dependencies": [
              2,
              4
            ],
            "details": "Configurar thresholds parametrizables (ej: 3+ reportes auto-eliminan), sistema de conteo automático, función de eliminación con notificación, logs de acciones automáticas, rollback manual posible",
            "status": "pending",
            "testStrategy": "Simular múltiples reportes del mismo comentario y verificar eliminación automática cuando se alcanza threshold",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Implementar sistema de notificaciones y seguimiento",
            "description": "Crear notificaciones para moderadores y seguimiento de acciones tomadas",
            "dependencies": [
              3,
              4,
              5
            ],
            "details": "Notificaciones en tiempo real para moderadores sobre nuevos reportes, sistema de historial de acciones por moderador, email notifications para usuarios afectados, dashboard de estadísticas y métricas de moderación",
            "status": "pending",
            "testStrategy": "Probar notificaciones llegan correctamente, verificar historial se guarda apropiadamente",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 6,
        "expansionPrompt": "Crear sistema para que estudiantes reporten comentarios inapropiados. Categorías de reporte: Spam, Acoso, Contenido Inapropiado, Otro. Máximo 1 reporte por usuario por comentario. Dashboard para moderadores mostrando reportes pendientes con prioridad por cantidad de reportes. Automatización threshold para auto-eliminar con múltiples reportes."
      },
      {
        "id": "24",
        "title": "Implementar carrusel interactivo de galería",
        "description": "Crear carrusel responsive para imágenes de eventos recientes",
        "details": "Auto-rotación cada 5 segundos (pausable). Botones prev/next funcionales. Mobile: swipe para navegar. Lazy loading de imágenes >3. Tiempo de carga <2 segundos. Imágenes desde Supabase Storage con transformaciones URL. Fully responsive en todas las resoluciones. Transiciones suaves CSS",
        "testStrategy": "Probar auto-rotación y pausa, verificar funcionamiento de botones prev/next, probar swipe en mobile, medir tiempo de carga <2s, y validar responsive en diferentes tamaños",
        "priority": "high",
        "dependencies": [
          "6"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Instalar y configurar Swiper.js",
            "description": "Instalar Swiper.js mediante npm y configurar la estructura básica del carrusel en el proyecto",
            "dependencies": [],
            "details": "Ejecutar npm install swiper. Importar CSS y JS de Swiper.js. Crear estructura HTML inicial con contenedor swiper-wrapper y swiper-slide. Configurar inicialización básica de Swiper.js en componente React/Vue/Angular según tecnología del proyecto",
            "status": "pending",
            "testStrategy": "Verificar que Swiper.js se instala correctamente y el carrusel básico se renderiza sin errores en consola",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar conexión con Supabase Storage",
            "description": "Configurar cliente de Supabase y crear función para obtener URLs de imágenes con transformaciones",
            "dependencies": [],
            "details": "Instalar @supabase/supabase-js. Configurar cliente con URL y clave de Supabase. Crear servicio/gancho para obtener imágenes de eventos recientes. Implementar transformaciones de URL (resize, crop, quality) usando parámetros de Supabase Storage",
            "status": "pending",
            "testStrategy": "Probar que se conecta correctamente a Supabase y obtiene URLs válidas con transformaciones aplicadas",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Configurar auto-rotación y pausado",
            "description": "Implementar auto-reproducción cada 5 segundos con capacidad de pausar al hover o touch",
            "dependencies": [
              1
            ],
            "details": "Configurar opción autoplay de Swiper.js con delay: 5000ms. Implementar pausa automática onMouseEnter y reanudación onMouseLeave. Para mobile, pausar onTouchStart y reanudar onTouchEnd. Agregar estado para controlar pausa/reanudación manual",
            "status": "pending",
            "testStrategy": "Verificar auto-rotación funciona cada 5 segundos, se pausa al hover/touch y reanuda correctamente",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implementar botones de navegación prev/next",
            "description": "Agregar botones funcionales de navegación anterior y siguiente con estilos responsive",
            "dependencies": [
              1
            ],
            "details": "Configurar navigation de Swiper.js con prevEl y nextEl. Crear botones personalizados con flechas SVG o iconos. Aplicar estilos CSS responsivos con hover effects. Asegurar posicionamiento correcto en diferentes tamaños de pantalla",
            "status": "pending",
            "testStrategy": "Probar que botones navegan correctamente entre slides, funcionan en mobile y tienen estilos adecuados",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implementar lazy loading optimizado",
            "description": "Configurar lazy loading para imágenes con load efficiency y placeholder",
            "dependencies": [
              2,
              1
            ],
            "details": "Configurar lazy loading de Swiper.js con loadPrevNext: 2. Implementar placeholder de bajo peso o skeleton mientras carga. Usar Intersection Observer API como fallback. Configurar preloading estratégico para imágenes cercanas. Medir y optimizar tiempo de carga <2 segundos",
            "status": "pending",
            "testStrategy": "Medir tiempo de carga de imágenes y verificar <2s, probar lazy loading con Network throttling",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Implementar swipe gestures para mobile",
            "description": "Configurar navegación táctil con gestos swipe en dispositivos móviles",
            "dependencies": [
              1
            ],
            "details": "Activar touchEvents y simulateTouch de Swiper.js. Configurar threshold óptimo para swipe detection. Implementar resistencia (resistance) y momentum para experiencia natural. Deshabilitar某些gestures en desktop si interfieren con mouse events",
            "status": "pending",
            "testStrategy": "Probar swipe gestures en dispositivos móviles reales y emulados en Chrome DevTools",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Implementar diseño responsive y transiciones",
            "description": "Asegurar funcionamiento completo en todas las resoluciones con transiciones CSS suaves",
            "dependencies": [
              4,
              6,
              5
            ],
            "details": "Configurar breakpoints de Swiper.js para diferentes tamaños (mobile: 1 slide, tablet: 2 slides, desktop: 3+ slides). Implementar CSS transitions suaves con cubic-bezier. Agregar transformaciones 3D para mejor rendimiento. Configurar aspect ratio consistente para imágenes. Implementar fallback para navegación sin JavaScript",
            "status": "pending",
            "testStrategy": "Probar en múltiples resoluciones móviles, tablet y desktop. Verificar transiciones suaves y rendimiento fluido",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 7,
        "expansionPrompt": "Crear carrusel responsive para imágenes de eventos recientes con Swiper.js. Auto-rotación cada 5 segundos (pausable). Botones prev/next funcionales. Mobile: swipe para navegar. Lazy loading de imágenes >3. Tiempo de carga <2 segundos. Imágenes desde Supabase Storage con transformaciones URL."
      },
      {
        "id": "25",
        "title": "Implementar sistema de gestión de imágenes",
        "description": "Crear sistema para subir/organizar imágenes en Supabase Storage",
        "details": "Soporte JPG, PNG, WebP. Compresión automática (máx 1MB). Drag-and-drop para organización. Búsqueda por descripción. Máximo 500 imágenes por galería. Interface responsive con vista en grid y lista. Metadatos guardados en base de datos. Backups automáticos",
        "testStrategy": "Probar upload de diferentes formatos, verificar compresión automática, probar drag-and-drop, probar búsqueda por descripción, y validar límite de 500 imágenes",
        "priority": "high",
        "dependencies": [
          "6"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configurar Supabase Storage y estructura de base de datos",
            "description": "Configurar bucket de Storage en Supabase y crear tabla de metadatos para imágenes",
            "dependencies": [],
            "details": "Crear bucket 'images' en Supabase Storage con políticas CORS. Crear tabla 'images' con campos: id, name, description, url, size, format, upload_date, gallery_id. Configurar RLS policies. Crear índices para búsqueda por descripción y galería.",
            "status": "pending",
            "testStrategy": "Verificar acceso al bucket, probar inserción en tabla de metadatos, validar RLS policies",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar servicio de compresión de imágenes",
            "description": "Crear función para comprimir imágenes automáticamente manteniendo calidad",
            "dependencies": [
              1
            ],
            "details": "Implementar función de compresión usando sharp library. Soportar JPG, PNG, WebP. Reducir tamaño si >1MB manteniendo calidad aceptable. Generar múltiples tamaños (thumbnail, medium, large). Cache de imágenes procesadas.",
            "status": "pending",
            "testStrategy": "Probar compresión con diferentes formatos y tamaños, verificar calidad vs tamaño, validar límite de 1MB",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Crear API endpoints para gestión de imágenes",
            "description": "Implementar endpoints RESTful para CRUD de imágenes",
            "dependencies": [
              1
            ],
            "details": "POST /api/images/upload con multipart form data. GET /api/images con paginación y filtros. PUT /api/images/:id para actualizar metadatos. DELETE /api/images/:id. GET /api/images/:id. Validación de tipos y tamaños de archivo.",
            "status": "pending",
            "testStrategy": "Probar todos los endpoints, validar autenticación, probar errores y límites",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implementar componente de drag-and-drop",
            "description": "Crear interfaz interactiva para subir múltiples archivos",
            "dependencies": [],
            "details": "Componente React con react-dropzone. Vista previa de archivos antes de subir. Barra de progreso individual y general. Validación de formatos (JPG, PNG, WebP). Cancelar uploads. Máximo 50 archivos simultáneos.",
            "status": "pending",
            "testStrategy": "Probar drag-and-drop con múltiples archivos, validar formatos, probar cancelación, probar límite de archivos",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Crear sistema de búsqueda y filtrado",
            "description": "Implementar búsqueda por descripción y filtros avanzados",
            "dependencies": [
              1,
              3
            ],
            "details": "Input de búsqueda con debounce. Filtros por formato, tamaño, fecha de subida. Ordenamiento por nombre, fecha, tamaño. Búsqueda full-text en descripción usando Supabase search. Paginación con 20 imágenes por página.",
            "status": "pending",
            "testStrategy": "Probar búsqueda por palabras clave, probar filtros combinados, verificar rendimiento con 500 imágenes",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Implementar vista de galería responsive",
            "description": "Crear interfaz de galería con vista grid y lista",
            "dependencies": [
              3,
              4,
              5
            ],
            "details": "Componente Gallery con toggle grid/list. Vista grid: 2-6 columnas responsive. Vista lista: detalles completos. Lazy loading con Intersection Observer. Infinite scroll o paginación. Selección múltiple para operaciones batch.",
            "status": "pending",
            "testStrategy": "Probar responsive en móviles, tablets, desktop. Probar toggle grid/list. Verificar lazy loading.",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Implementar sistema de organización y galerías",
            "description": "Crear sistema para organizar imágenes en galerías",
            "dependencies": [
              1,
              3
            ],
            "details": "Tabla 'galleries' con nombre y descripción. Relación muchos-a-muchos entre images y galleries. CRUD operations para galerías. Mover imágenes entre galerías. Galería por defecto 'Uncategorized'. Límite de 500 imágenes por galería.",
            "status": "pending",
            "testStrategy": "Probar creación de galerías, mover imágenes entre galerías, validar límite de 500 imágenes",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Implementar sistema de backups automáticos",
            "description": "Configurar backups automáticos de imágenes y metadatos",
            "dependencies": [
              1,
              3
            ],
            "details": "Job programado diario para backup a storage externo. Compresión de backups. Retención de 30 días. Logs de backup exitosos/fracasados. Recuperación selectiva de imágenes. Monitor de uso de storage.",
            "status": "pending",
            "testStrategy": "Probar backup automático, verificar integridad de backup, probar recuperación, validar retención",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 8,
        "expansionPrompt": "Crear sistema para subir/organizar imágenes en Supabase Storage. Soporte JPG, PNG, WebP. Compresión automática (máximo 1MB). Drag-and-drop para organización. Búsqueda por descripción. Máximo 500 imágenes por galería. Interface responsive con vista en grid y lista. Metadatos guardados en base de datos. Backups automáticos."
      },
      {
        "id": "26",
        "title": "Implementar optimización de imágenes responsive",
        "description": "Generar thumbnails y versiones responsive automáticamente",
        "details": "Thumbnail 200x200px (<50KB) para vistas previas. Versión mobile 480px ancho (<200KB). Versión desktop 1200px ancho (<400KB). Formato WebP cuando navegador lo soporte. Transformaciones en URL de Supabase CDN. Caching automático 24h. Lazy loading con intersection observer",
        "testStrategy": "Probar que thumbnails se generen automáticamente, verificar diferentes tamaños responsive, probar WebP vs JPG/PNG, medir tamaños de archivo, y validar caching",
        "priority": "medium",
        "dependencies": [
          "25"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configurar Supabase Storage CDN y transformaciones de imágenes",
            "description": "Implementar la configuración inicial de Supabase Storage con parámetros CDN y transformaciones de imágenes",
            "dependencies": [],
            "details": "Crear funciones helper para generar URLs transformadas con Supabase Storage CDN. Configurar parámetros de calidad, formato y dimensiones. Implementar validación de WebP support en el navegador. Setup de headers de caché de 24 horas",
            "status": "pending",
            "testStrategy": "Probar que las URLs transformadas funcionen correctamente, verificar formato WebP vs JPG/PNG según navegador, medir tamaños de archivo generados, y validar headers de caché",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar componente ImageOptimizer con lazy loading",
            "description": "Crear componente React que maneje la optimización automática de imágenes con Intersection Observer",
            "dependencies": [
              1
            ],
            "details": "Desarrollar componente ImageOptimizer que acepte src, alt, loading priority. Implementar Intersection Observer para lazy loading. Generar srcset con múltiples tamaños (200px, 480px, 1200px). Agregar placeholder blur o skeleton loading. Manejar errores de carga de imágenes",
            "status": "pending",
            "testStrategy": "Probar lazy loading en diferentes tamaños de pantalla, verificar que las imágenes carguen según scroll, medir peso de archivos generados, y probar fallbacks para errores de carga",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar sistema de thumbnails y caché",
            "description": "Crear sistema para generar y cachear thumbnails automáticamente con metadatos",
            "dependencies": [
              1
            ],
            "details": "Desarrollar sistema de caché en localStorage o memoria para thumbnails. Implementar prefetching de imágenes críticas. Crear sistema de metadatos para controlar versiones cacheadas. Setup de políticas de invalidación de caché (24h)",
            "status": "pending",
            "testStrategy": "Probar que thumbnails se cachéen correctamente, verificar expiración de caché de 24h, medir mejora en tiempos de carga con caché, y probar invalidación de caché",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implementar Picture component con breakpoints responsive",
            "description": "Crear componente que seleccione automáticamente el tamaño óptimo según dispositivo",
            "dependencies": [
              1
            ],
            "details": "Crear componente Picture con media queries para mobile (≤480px) y desktop (≥1200px). Implementar WebP fallback automático. Agregar dimensiones calculadas según viewport. Integrar con sistema de transformaciones de Supabase. Manejar loading states y errores",
            "status": "pending",
            "testStrategy": "Probar responsive behavior en diferentes dispositivos, verificar selección correcta de tamaños (mobile 480px, desktop 1200px), medir tamaños de archivo en cada breakpoint, y probar WebP fallback",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Integrar optimización en componentes existentes",
            "description": "Actualizar componentes que usan imágenes para utilizar el nuevo sistema de optimización",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Identificar todos los componentes que renderizan imágenes en la aplicación. Reemplazar etiquetas <img> estándar con componentes ImageOptimizer o Picture. Actualizar imports y props necesarios. Migrar imágenes estáticas a Supabase Storage si aplica. Ajustar estilos CSS si es necesario",
            "status": "pending",
            "testStrategy": "Probar que todas las imágenes se carguen correctamente con el nuevo sistema, verificar que no haya regresiones visuales, medir mejora en tiempos de carga de la aplicación, y probar en diferentes dispositivos y tamaños de pantalla",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Implementar monitoring y validación de optimización",
            "description": "Configurar sistema para monitorear el rendimiento y la efectividad de la optimización de imágenes",
            "dependencies": [
              5
            ],
            "details": "Implementar métricas para medir tiempos de carga de imágenes. Crear sistema de logging para errores de carga de imágenes. Configurar alerts cuando las imágenes excedan límites de peso. Agregar visual testing para validar renderizado correcto. Integrar con sistema de monitoring general de la aplicación",
            "status": "pending",
            "testStrategy": "Probar que las métricas se registren correctamente, verificar que las alertas funcionen, medir impacto real en performance de la aplicación, y validar que todas las imágenes carguen sin errores",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 6,
        "expansionPrompt": "Generar thumbnails y versiones responsive automáticamente con Supabase Storage transformaciones. Thumbnail 200x200px (<50KB) para vistas previas. Versión mobile 480px ancho (<200KB). Versión desktop 1200px ancho (<400KB). Formato WebP cuando navegador lo soporte. Caching automático 24h. Lazy loading con intersection observer."
      },
      {
        "id": "27",
        "title": "Implementar dashboard principal de administración",
        "description": "Crear dashboard con estadísticas principales y acciones rápidas",
        "details": "Carga en <2 segundos. Muestra: total noticias, comentarios pendientes, usuarios activos (hoy/mes). Gráfico de tendencia de engagement (últimas 4 semanas) con recharts o similar. Botones rápidos: Nueva noticia, Ver reportes, Moderar comentarios. Responsive en tablet y desktop. Actualización en tiempo real",
        "testStrategy": "Verificar tiempo de carga <2s, probar que estadísticas sean correctas, verificar gráfico de tendencia, probar botones rápidos, y validar responsive en tablet",
        "priority": "high",
        "dependencies": [
          "16",
          "22"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configurar estructura base del dashboard",
            "description": "Crear la estructura fundamental del componente dashboard con Next.js y TypeScript",
            "dependencies": [],
            "details": "Implementar componente DashboardPage con layout responsivo. Configurar estructura de carpetas para componentes del dashboard. Definir tipo de datos TypeScript para métricas y estadísticas. Establecer hook personalizado para datos del dashboard",
            "status": "pending",
            "testStrategy": "Verificar renderizado correcto del componente base, probar responsividad básica, validar tipos TypeScript sin errores, y comprobar estructura de carpetas",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar API para métricas principales",
            "description": "Crear endpoint optimizado que devuelva estadísticas en menos de 2 segundos",
            "dependencies": [
              1
            ],
            "details": "Crear /api/admin/dashboard/metrics con query optimizadas. Implementar cache con Redis para estadísticas complejas. Estructurar respuesta con: total_noticias, comentarios_pendientes, usuarios_activos_hoy, usuarios_activos_mes. Agregar logging de performance",
            "status": "pending",
            "testStrategy": "Medir tiempo de respuesta <2s con Artillery, verificar datos correctos con unit tests, probar cache reduce tiempos, y validar estructura JSON de respuesta",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Crear componentes de tarjetas estadísticas",
            "description": "Implementar tarjetas individuales para mostrar cada métrica principal",
            "dependencies": [
              1,
              2
            ],
            "details": "Crear StatCard component con iconos de react-icons. Implementar MetricCard para: total noticias, comentarios pendientes, usuarios hoy, usuarios mes. Agregar loading skeletons y manejo de errores. Aplicar animaciones suaves con Framer Motion",
            "status": "pending",
            "testStrategy": "Probar renderizado correcto con datos mockeados, verificar estados loading/error, probar iconos consistentes, y validar responsividad móvil/tablet",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implementar gráfico de tendencia con Recharts",
            "description": "Crear gráfico de engagement de las últimas 4 semanas con Recharts",
            "dependencies": [
              1,
              2
            ],
            "details": "Crear EngagementTrendChart con Recharts. Formato de datos para últimas 4 semanas. Implementar responsive container. Agregar tooltip personalizado. Manejar loading y error states. Configurar colores y estilos personalizados",
            "status": "pending",
            "testStrategy": "Probar renderizado con datos ejemplo, verificar responsividad在不同 tamaños, validar tooltip informativo, y probar carga sin datos",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implementar botones de acciones rápidas",
            "description": "Crear botones principales para acciones frecuentes del administrador",
            "dependencies": [
              1
            ],
            "details": "Crear QuickActions component con botones: Nueva Noticia (link a /admin/news/new), Ver Reportes (modal o página), Moderar Comentarios (link a /admin/moderation). Implementar variantes de tamaño responsive. Agregar iconos y hover effects. Configurar loading states",
            "status": "pending",
            "testStrategy": "Verificar navegación correcta a cada acción, probar hover y focus states, validar iconos visibles, y comprobar responsividad tablet/desktop",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Implementar actualización en tiempo real",
            "description": "Configurar WebSocket para actualización automática de métricas del dashboard",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Configurar WebSocket con Supabase realtime. Implementar hook useRealtimeDashboard. Suscribirse a cambios en noticias, comentarios, usuarios. Actualizar componentes sin re-render completo. Manejar conexión/reconexión. Agregar indicador de conexión",
            "status": "pending",
            "testStrategy": "Probar actualización automática al crear contenido, verificar reconexión automática, probar indicador de conexión activo, y validar que no hay memory leaks",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Configurar layout responsivo completo",
            "description": "Asegurar diseño óptimo en tablet y desktop con CSS Grid y Flexbox",
            "dependencies": [
              3,
              4,
              5
            ],
            "details": "Implementar layout CSS Grid para dashboard completo. Configurar breakpoints: mobile (hidden), tablet (768px), desktop (1024px). Optimizar espaciado y distribución. Aplicar glass morphism effects. Configurar container queries para componentes específicos",
            "status": "pending",
            "testStrategy": "Probar en múltiples tamaños de pantalla, verificar Chrome DevTools Device Mode, validar layout no se rompe en tablet, y comprobar performance de CSS",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Implementar manejo de errores y fallbacks",
            "description": "Crear sistema robusto de manejo de errores con estados de carga y recuperación",
            "dependencies": [
              2,
              3,
              4,
              6
            ],
            "details": "Implementar ErrorBoundary con retry functionality. Crear DashboardError component con mensaje claro. Configurar fallback para cada componente. Implementar mecanismo de refresco manual. Agregar logging de errores con Sentry. Crear skeleton loading states",
            "status": "pending",
            "testStrategy": "Simular errores de red/API, probar recuperación manual, verificar skeletons renderizan correctamente, validar errores se logean, y probar experiencia offline",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 8,
        "expansionPrompt": "Crear dashboard con estadísticas principales y acciones rápidas. Carga en <2 segundos. Muestra: total noticias, comentarios pendientes, usuarios activos (hoy/mes). Gráfico de tendencia de engagement (últimas 4 semanas) con recharts o similar. Botones rápidos: Nueva noticia, Ver reportes, Moderar comentarios. Responsive en tablet y desktop."
      },
      {
        "id": "28",
        "title": "Implementar gestor de contenido de noticias",
        "description": "Crear interfaz para CRUD de noticias con preview en tiempo real",
        "details": "Tabla listando noticias con búsqueda/filtros full-text. Botón crear abre formulario completo con vista previa lado-a-lado. Edición in-place de cambios menores. Confirmación antes de eliminar. Historial de versiones para últimas 3 versiones. Design responsive conDataTables o similar",
        "testStrategy": "Probar CRUD completo de noticias, verificar búsqueda y filtros, probar vista previa en tiempo real, probar confirmación de eliminación, y validar historial de versiones",
        "priority": "high",
        "dependencies": [
          "11",
          "18"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configurar estructura base de datos para noticias",
            "description": "Crear modelo de datos para noticias con campos necesarios y relaciones para versionamiento",
            "dependencies": [],
            "details": "Definir schema de tabla news con id, titulo, contenido, excerpt, imagen, created_at, updated_at, deleted_at. Crear tabla news_versions con id_news, version, contenido, created_at. Configurar índices para búsqueda full-text en titulo y contenido",
            "status": "pending",
            "testStrategy": "Verificar creación de tablas, probar índices de búsqueda full-text, validar relaciones foreign key",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar backend API endpoints CRUD para noticias",
            "description": "Crear endpoints RESTful para operaciones completas de gestión de noticias",
            "dependencies": [
              1
            ],
            "details": "Implementar GET /api/news (listado con paginación), GET /api/news/:id, POST /api/news, PUT /api/news/:id, DELETE /api/news/:id. Agregar parámetros de búsqueda q y filtros por fecha/categoría. Implementar middleware de autenticación",
            "status": "pending",
            "testStrategy": "Probar todos los endpoints con Postman, verificar respuesta de errores, probar paginación y filtros",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Crear interfaz de listado con DataTables",
            "description": "Implementar tabla responsive con búsqueda y filtros avanzados",
            "dependencies": [
              2
            ],
            "details": "Configurar DataTables.js con server-side processing. Implementar búsqueda instantánea con debounce. Agregar filtros por fecha, estado, categoría. Diseño responsive con acciones colapsables en móviles. Paginación del lado del servidor",
            "status": "pending",
            "testStrategy": "Probar rendimiento con 1000+ registros, probar filtros combinados, verificar responsive en móviles, probar keyboard navigation",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implementar formulario de creación con vista previa",
            "description": "Crear formulario completo con vista previa en tiempo real lado a lado",
            "dependencies": [
              3
            ],
            "details": "Diseñar layout split-screen: formulario a la izquierda, vista previa a la derecha. Implementar editor de texto enriquecido con toolbar. Vista previa actualizada automáticamente al escribir. Modo fullscreen disponible. Validación en tiempo real de campos",
            "status": "pending",
            "testStrategy": "Probar renderizado de markdown, verificar actualización en tiempo real, probar validación de formulario, probar modo fullscreen",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implementar edición in-place y modal para cambios mayores",
            "description": "Permitir edición rápida inline y edición completa en modal",
            "dependencies": [
              4
            ],
            "details": "Hacer clic en título/resumen editable inline con double-click. Guardado automático con debounce. Botón 'Editar completo' que abre modal con formulario completo. Detectar cambios y guardar solo campos modificados",
            "status": "pending",
            "testStrategy": "Probar edición inline, probar guardado automático, probar modal de edición completa, verificar que solo se guarden cambios",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Implementar historial de versiones y restauración",
            "description": "Guardar automáticamente versiones y permitir restaurar versiones anteriores",
            "dependencies": [
              2
            ],
            "details": "Crear trigger para guardar versión antes de cada actualización. Mantener últimas 3 versiones por noticia. Implementar endpoint GET /api/news/:id/versions. Botón restaurar en interfaz con confirmación",
            "status": "pending",
            "testStrategy": "Verificar creación automática de versiones, probar restauración de versiones, probar límite de 3 versiones, probar permisos de acceso",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Implementar sistema de confirmación de eliminación",
            "description": "Agregar diálogo de confirmación con vista previa antes de eliminar",
            "dependencies": [
              5
            ],
            "details": "Modal de confirmación con vista previa completa de noticia a eliminar. Botones 'Cancelar' y 'Eliminar permanentemente'. Mensaje de advertencia claro. Opción de archivo temporal antes de eliminación permanente",
            "status": "pending",
            "testStrategy": "Probar modal de confirmación, verificar vista previa en modal, probar cancelación, verificar eliminación permanente",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Implementar búsqueda full-text optimizada",
            "description": "Crear motor de búsqueda con highlighting de resultados",
            "dependencies": [
              1,
              3
            ],
            "details": "Configurar búsqueda full-text con PostgreSQL tsvector. Implementar destacado de términos coincidentes en resultados. Búsqueda en título con mayor peso. Ordenamiento por relevancia. Índices optimizados para búsquedas frecuentes",
            "status": "pending",
            "testStrategy": "Probar búsqueda con términos múltiples, verificar highlighting, probar ordenamiento por relevancia, medir rendimiento de búsquedas",
            "parentId": "undefined"
          },
          {
            "id": 9,
            "title": "Implementar funcionalidad de vista previa y previsualización",
            "description": "Crear sistema de vista previa en tiempo real para contenido",
            "dependencies": [
              4,
              8
            ],
            "details": "Implementar vista previa de markdown con sanitize de HTML. Renderizado de imágenes con lazy loading. Vista previa de meta descripción y SEO. Previsualización de cómo se verá en lista. Modo oscuro/claro para vista previa",
            "status": "pending",
            "testStrategy": "Probar renderizado markdown, verificar sanitización de HTML, probar lazy loading de imágenes, probar modo oscuro/claro",
            "parentId": "undefined"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 9,
        "expansionPrompt": "Crear interfaz para CRUD de noticias con vista previa en tiempo real. Tabla listando noticias con búsqueda/filtros full-text. Botón crear abre formulario completo con vista previa lado-a-lado. Edición in-place de cambios menores. Confirmación antes de eliminar. Historial de versiones para últimas 3 versiones. Design responsive con DataTables o similar."
      },
      {
        "id": "29",
        "title": "Implementar gestor de usuarios y roles",
        "description": "Crear interfaz para gestionar usuarios, roles y permisos",
        "details": "Tabla con búsqueda/filtros por rol, estado, fecha registro. Cambio de rol mediante dropdown (actualiza RLS policies). Deshabilitar usuario sin eliminar datos. Auditoría: quién cambió qué y cuándo. Bulk actions para asignar rol a múltiples. Responsive design con acciones masivas",
        "testStrategy": "Probar cambio de rol y verificar RLS actualizado, probar deshabilitación de usuario, probar bulk actions, verificar auditoría, y validar responsive en mobile",
        "priority": "high",
        "dependencies": [
          "9",
          "10"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configurar base de datos y policies RLS",
            "description": "Crear estructura de base de datos para usuarios, roles y tabla de auditoría con Row Level Security policies",
            "dependencies": [],
            "details": "Diseñar schema con tabla usuarios, roles, many-to-many relationship, y auditoría. Configurar RLS policies que actualizan automáticamente según rol asignado mediante dropdown.",
            "status": "pending",
            "testStrategy": "Verificar que RLS funcione correctamente con diferentes roles y que auditoría registre cambios",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar API endpoints para gestión de usuarios",
            "description": "Crear endpoints para CRUD de usuarios con filtros y búsqueda avanzada",
            "dependencies": [
              1
            ],
            "details": "Implementar endpoints para: listar usuarios con filtros (rol, estado, fecha), actualizar rol, deshabilitar usuario, bulk actions. Incluir paginación y ordenamiento.",
            "status": "pending",
            "testStrategy": "Probar todos los endpoints con diferentes filtros y casos límite",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Crear sistema de auditoría y tracking",
            "description": "Implementar logging completo de quién cambió qué y cuándo",
            "dependencies": [
              1
            ],
            "details": "Crear triggers o middleware que registre todas las acciones importantes: cambios de rol, deshabilitaciones, bulk actions. Incluir timestamp, usuario que realiza acción, y valores anteriores/nuevos.",
            "status": "pending",
            "testStrategy": "Verificar que cada acción quede registrada en auditoría con todos los datos requeridos",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Diseñar interfaz principal de gestión de usuarios",
            "description": "Crear layout responsive con tabla principal de usuarios y controles de filtros",
            "dependencies": [
              2
            ],
            "details": "Implementar tabla responsiva con búsqueda, filtros por rol, estado y fecha. Incluir paginación, ordenamiento y diseño mobile-first.",
            "status": "pending",
            "testStrategy": "Probar responsive en diferentes tamaños de pantalla y usabilidad en móviles",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implementar dropdown para cambio de roles",
            "description": "Crear componente dropdown que actualice roles en tiempo real",
            "dependencies": [
              4
            ],
            "details": "Dropdown con roles disponibles, validación de permisos, actualización via API con refresh automático de RLS policies. Incluir confirmación y feedback visual.",
            "status": "pending",
            "testStrategy": "Verificar que cambio de rol se refleje inmediatamente en permisos del sistema",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Implementar acciones bulk y selección múltiple",
            "description": "Crear funcionalidad para seleccionar múltiples usuarios y aplicar acciones en lote",
            "dependencies": [
              4
            ],
            "details": "Checkboxes para selección, select all, bulk actions para asignar roles, deshabilitar usuarios, etc. Incluir progress indicators y rollback en caso de errores.",
            "status": "pending",
            "testStrategy": "Probar bulk actions con diferentes cantidades de usuarios y manejo de errores parciales",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Crear sistema de deshabilitación de usuarios",
            "description": "Implementar soft delete que preserve datos históricos",
            "dependencies": [
              2
            ],
            "details": "Campo isActive/estado en lugar de eliminación física. Mantener todos los datos históricos y relaciones. Incluir opción de rehabilitación y tracking de estado.",
            "status": "pending",
            "testStrategy": "Verificar que usuarios deshabilitados conserven datos y no puedan acceder al sistema",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Implementar dashboard de auditoría y logs",
            "description": "Crear interfaz para consultar y filtrar historial de cambios",
            "dependencies": [
              3,
              4
            ],
            "details": "Dashboard con tabla de auditoría, filtros por usuario, acción, fecha. Incluir exportación de logs y búsqueda avanzada. Vista detallada de cada cambio con valores before/after.",
            "status": "pending",
            "testStrategy": "Probar que todos los cambios se reflejen correctamente en dashboard y filtros funcionen",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 8,
        "expansionPrompt": "Crear interfaz para gestionar usuarios, roles y permisos. Tabla con búsqueda/filtros por rol, estado, fecha registro. Cambio de rol mediante dropdown (actualiza RLS policies). Deshabilitar usuario sin eliminar datos. Auditoría: quién cambió qué y cuándo. Bulk actions para asignar rol a múltiples. Responsive design con acciones masivas."
      },
      {
        "id": "30",
        "title": "Implementar panel de moderación de contenido",
        "description": "Crear interfaz para moderadores revisar y aprobar/rechazar contenido",
        "details": "Cola de comentarios pendientes (is_approved = FALSE). Preview del contexto (noticia/tópico original). Botones: Aprobar, Rechazar (con razón). Notificación automática al usuario. Query eficiente para obtener pendientes con paginación. Filtros por categoría de reporte",
        "testStrategy": "Probar flujo completo de moderación, verificar preview de contexto, probar aprobación y rechazo, verificar notificación automática, y medir rendimiento con muchos pendientes",
        "priority": "high",
        "dependencies": [
          "22",
          "23"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear componentes básicos del panel de moderación",
            "description": "Desarrollar la estructura fundamental del panel con componentes React para la lista de contenido pendiente y vista principal",
            "dependencies": [],
            "details": "Crear layout principal con sidebar de navegación, área de contenido principal, y estructura básica. Implementar componentes reutilizables para tarjetas de contenido pendiente. Configurar routing para el panel de moderación",
            "status": "pending",
            "testStrategy": "Verificar renderizado correcto de componentes, probar navegación básica del panel, y validar estructura responsive",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar API para obtener contenido pendiente",
            "description": "Crear endpoint optimizado para consultar contenido sin aprobar con paginación eficiente",
            "dependencies": [],
            "details": "Desarrollar API endpoint GET /api/moderation/pending con query params: page, limit, category, date_range. Implementar índices eficientes en base de datos. Incluir conteo total para UI de paginación",
            "status": "pending",
            "testStrategy": "Probar rendimiento con 1000+ registros pendientes, verificar paginación funciona correctamente, y medir tiempos de respuesta",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Crear vista previa del contexto original",
            "description": "Implementar componente para mostrar el contexto completo (noticia/tópico original) asociado al contenido a moderar",
            "dependencies": [
              1,
              2
            ],
            "details": "Desarrollar componente ModalPreviewContext que carga y muestra noticia/tópico original con formato legible. Incluir información del autor, fecha de publicación, y contexto relacionado. Implementar lazy loading para contenido largo",
            "status": "pending",
            "testStrategy": "Probar vista previa con diferentes tipos de contenido, verificar carga de datos relacionados, y validar formato consistente",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implementar sistema de filtros por categoría de reporte",
            "description": "Crear interfaz y lógica para filtrar contenido pendiente por diferentes categorías de reporte",
            "dependencies": [
              1,
              2
            ],
            "details": "Desarrollar componente FilterPanel con categorías: spam, contenido ofensivo, desinformación, copyright, etc. Implementar filtrado del lado del servidor con SQL optimizado. Incluir estado persistente de filtros",
            "status": "pending",
            "testStrategy": "Probar todas las categorías de filtro, verificar persistencia de selección, y validar resultados correctos",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implementar botones de aprobar/rechazar con razones",
            "description": "Crear interfaz para acciones de moderación con selección de motivos específicos",
            "dependencies": [
              1,
              3
            ],
            "details": "Desarrollar componente ActionButtons con botones Aprobar y Rechazar. Para rechazo, incluir dropdown con razones predefinidas y campo de texto personalizado. Implementar confirmación antes de enviar decisión",
            "status": "pending",
            "testStrategy": "Probar ambas acciones de moderación, verificar validación de razones obligatorias, y probar confirmación de acción",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Crear sistema de notificaciones automáticas",
            "description": "Implementar envío de notificaciones al usuario cuando su contenido es aprobado o rechazado",
            "dependencies": [
              5
            ],
            "details": "Desarrollar sistema de notificaciones vía email y notificaciones push en-app. Crear templates personalizados para aprobación/rechazo. Incluir razón específica cuando es rechazado. Implementar cola de notificaciones para envío masivo",
            "status": "pending",
            "testStrategy": "Probar envío de notificaciones para ambos casos, verificar contenido personalizado, y probar cola de procesamiento",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Implementar paginación optimizada y rendimiento",
            "description": "Optimizar el rendimiento del panel con paginación virtual y lazy loading para manejar grandes volúmenes",
            "dependencies": [
              2,
              4
            ],
            "details": "Implementar infinite scroll con React Query para cache optimizado. Agregar skeleton loaders mientras carga contenido. Optimizar queries con SELECT específicos. Implementar refresh inteligente en segundo plano",
            "status": "pending",
            "testStrategy": "Probar rendimiento con 10,000+ pendientes, verificar smooth scrolling, medir tiempos de carga, y probar cache behavior",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 7,
        "expansionPrompt": "Crear interfaz para moderadores revisar y aprobar/rechazar contenido. Cola de comentarios pendientes (is_approved = FALSE). Preview del contexto (noticia/tópico original). Botones: Aprobar, Rechazar (con razón). Notificación automática al usuario. Query eficiente para obtener pendientes con paginación. Filtros por categoría de reporte."
      },
      {
        "id": "31",
        "title": "Implementar sistema de analytics y reportes",
        "description": "Crear panel con KPIs de engagement y métricas principales",
        "details": "Usuarios activos (diarios/mensuales) desde tabla users. Noticias más leídas (ORDER BY view_count DESC). Comentarios por tópico. Tasa de participación por categoría. Exportar a CSV. Responsive con gráficos interactivos. Datos cacheados por 1 hora para performance",
        "testStrategy": "Verificar que métricas sean correctas, probar exportación a CSV, probar gráficos interactivos, medir rendimiento con mucho datos, y validar responsive",
        "priority": "medium",
        "dependencies": [
          "27",
          "30"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Analizar estructura de base de datos y métricas existentes",
            "description": "Investigar tablas users, news, comments para identificar campos necesarios para KPIs y métricas de engagement",
            "dependencies": [],
            "details": "Examinar esquema de base de datos actual. Identificar campos relevantes: created_at, last_login, view_count, category_id, user_id. Determinar queries óptimas para calcular usuarios activos diarios/mensuales y métricas de engagement.",
            "status": "pending",
            "testStrategy": "Verificar que queries devuelven resultados correctos con datos de prueba",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar backend API para KPIs y métricas",
            "description": "Crear endpoints RESTful para obtener usuarios activos, noticias populares, comentarios y tasas de participación",
            "dependencies": [
              1
            ],
            "details": "Desarrollar endpoint /api/analytics/kpis con sub-rutas: active-users, top-news, comments-by-topic, participation-rate. Implementar lógica para calcular usuarios activos (últimos 24h, 30 días). Queries optimizadas con índices adecuados.",
            "status": "pending",
            "testStrategy": "Test unitarios para cada endpoint, pruebas de integración con datos reales, validación de responses",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar sistema de caché por 1 hora",
            "description": "Configurar Redis o similar para cachear respuestas de analytics y mejorar rendimiento",
            "dependencies": [
              2
            ],
            "details": "Instalar y configurar Redis. Implementar middleware de caché con TTL de 1 hora para endpoints de analytics. Estrategia de cache invalidación selective. Keys estructuradas por tipo de métrica y periodo de tiempo.",
            "status": "pending",
            "testStrategy": "Verificar respuesta cacheada vs fresca, medir tiempo de respuesta, probar cache invalidación",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Crear componente principal del dashboard de analytics",
            "description": "Implementar layout responsive con framework de gráficos interactivos (Chart.js o similar)",
            "dependencies": [
              3
            ],
            "details": "Diseñar layout responsive con grid system. Secciones: KPIs principales (tarjetas), gráficos interactivos (líneas, barras, torta), filtros por período. Implementar manejo de estados loading/error/responsive design con breakpoints móviles/tablet/desktop.",
            "status": "pending",
            "testStrategy": "Pruebas de responsive en diferentes tamaños, testing de interactividad de gráficos, accesibilidad de dashboard",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implementar visualizaciones de datos interactivas",
            "description": "Crear gráficos dinámicos para usuarios activos, tendencias de noticias y análisis de comentarios",
            "dependencies": [
              4
            ],
            "details": "Gráfico de líneas para usuarios activos (diario/mensual). Gráfico de barras para noticias más leídas. Gráfico de torta para distribución por categoría. Gráfico de dispersión para tasas de participación. Tooltips interactivos, leyendas dinámicas, animaciones suaves.",
            "status": "pending",
            "testStrategy": "Verificar renderizado correcto con diferentes volúmenes de datos, probar interactividad, test de accesibilidad",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Implementar funcionalidad de exportación a CSV",
            "description": "Crear sistema para exportar métricas y datos filtrados a formato CSV",
            "dependencies": [
              5
            ],
            "details": "Botón de exportación en cada sección del dashboard. Backend endpoint /api/analytics/export con filtros aplicables. Implementar CSV generation con headers apropiados, encoding UTF-8, formateo de fechas y números. Descarga automática del archivo generado.",
            "status": "pending",
            "testStrategy": "Verificar formato CSV correcto, probar con diferentes filtros, validar encoding de caracteres, test con grandes volúmenes",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Implementar filtros avanzados y testing completo",
            "description": "Añadir filtros por rango de fechas, categorías y otros parámetros; pruebas E2E completas",
            "dependencies": [
              6
            ],
            "details": "Filtros: rango de fechas (date picker), categorías (multi-select), usuarios específicos, tipo de métrica. Implementar debounce para búsquedas. Pruebas E2E con Cypress para todo el flujo. Performance testing con datos masivos. Testing de accesibilidad completo.",
            "status": "pending",
            "testStrategy": "Testing E2E completo, pruebas de carga con datos masivos, validación WCAG para dashboard, pruebas de cross-browser",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 7,
        "expansionPrompt": "Crear panel con KPIs de engagement y métricas principales. Usuarios activos (diarios/mensuales) desde tabla users. Noticias más leídas (ORDER BY view_count DESC). Comentarios por tópico. Tasa de participación por categoría. Exportar a CSV. Responsive con gráficos interactivos. Datos cacheados por 1 hora para performance."
      },
      {
        "id": "32",
        "title": "Configurar deployment en Vercel",
        "description": "Establecer pipeline de CI/CD automático con Vercel",
        "details": "Configurar vercel.json con build settings optimizados. Auto-deploy en cada push a main. Preview deployments para PRs. Automatic edge caching. Environment variables configuradas. Custom domain setup. Analytics integrado. Optimización para Next.js 14 serverless",
        "testStrategy": "Probar deployment automático, verificar preview deployments funcionen, probar custom domain, verificar analytics, y validar performance en producción",
        "priority": "high",
        "dependencies": [
          "31"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear y configurar archivo vercel.json",
            "description": "Establecer configuración base para deployment optimizado en Vercel",
            "dependencies": [],
            "details": "Crear archivo vercel.json con configuración específica para Next.js 14: buildCommand, outputDirectory, framework, installCommand, y region optimization para edge functions",
            "status": "pending",
            "testStrategy": "Validar sintaxis JSON y que la configuración se aplique correctamente en deployment",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Configurar environment variables en Vercel",
            "description": "Establecer todas las variables de entorno necesarias para producción",
            "dependencies": [
              1
            ],
            "details": "Configurar NEXT_PUBLIC_SUPABASE_URL, NEXT_PUBLIC_SUPABASE_ANON_KEY, y otras variables críticas del proyecto en el dashboard de Vercel con valores de producción",
            "status": "pending",
            "testStrategy": "Verificar que las variables se carguen correctamente en producción mediante logs y endpoints de prueba",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Configurar custom domain y edge caching",
            "description": "Establecer dominio personalizado y optimización de caché para mejor rendimiento",
            "dependencies": [
              1,
              2
            ],
            "details": "Añadir dominio personalizado en Vercel dashboard, configurar DNS correctamente, y establecer reglas de edge caching para assets estáticos y páginas dinámicas",
            "status": "pending",
            "testStrategy": "Probar que el dominio resuelva correctamente, verificar caché headers en respuestas, y validar rendimiento con herramientas de análisis",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implementar GitHub Actions para auto-deploy",
            "description": "Configurar pipeline CI/CD para deployment automático en cada push",
            "dependencies": [
              3
            ],
            "details": "Crear workflow de GitHub Actions que dispare deployment en Vercel automáticamente para cada push a main branch, con preview deployments para PRs",
            "status": "pending",
            "testStrategy": "Probar workflow con commits de prueba, verificar preview deployments para PRs, y confirmar que el auto-deploy funcione",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Integrar analytics y optimización final",
            "description": "Configurar analytics de Vercel y ajustes finales de rendimiento",
            "dependencies": [
              4
            ],
            "details": "Activar Vercel Analytics, configurar Speed Insights, Web Vitals, y optimizar build settings para máximo rendimiento serverless con Next.js 14",
            "status": "pending",
            "testStrategy": "Verificar que los datos de analytics se capturen correctamente, probar métricas de rendimiento, y validar optimizaciones de carga",
            "parentId": "undefined"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Establecer pipeline de CI/CD automático con Vercel. Configurar vercel.json con build settings optimizados. Auto-deploy en cada push a main. Preview deployments para PRs. Automatic edge caching. Environment variables configuradas. Custom domain setup. Analytics integrado. Optimización para Next.js 14 serverless."
      },
      {
        "id": "33",
        "title": "Implementar optimización de performance",
        "description": "Optimizar aplicación para Lighthouse score ≥90",
        "details": "Implementar Next.js Image para lazy loading automático. Code splitting dinámico. Caching estratégico con stale-while-revalidate. Bundle analysis para identificar oportunidades. Minificación CSS/JS. Preload critical resources. Service Worker para offline básico. Optimización Core Web Vitals",
        "testStrategy": "Ejecutar Lighthouse audit y verificar score ≥90, medir First Contentful Paint <1.8s, medir Largest Contentful Paint <2.5s, verificar Cumulative Layout Shift <0.1, y probar Time to Interactive <3.5s",
        "priority": "high",
        "dependencies": [
          "32"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Analizar performance baseline y configurar herramientas",
            "description": "Ejecutar Lighthouse audit inicial para identificar métricas actuales y configurar herramientas de análisis",
            "dependencies": [],
            "details": "Instalar Lighthouse CLI y extension en Chrome. Ejecutar audit completo en desktop y móvil. Documentar métricas actuales: FCP, LCP, CLS, TTI, bundle size, y score total. Configurar Web Vitals Chrome extension para monitoring en tiempo real",
            "status": "pending",
            "testStrategy": "Verificar que Lighthouse audit se ejecuta correctamente y genera reporte con métricas baseline. Confirmar que todas las herramientas de análisis están funcionando",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar Next.js Image optimization",
            "description": "Configurar y optimizar todas las imágenes usando Next.js Image component para lazy loading automático",
            "dependencies": [
              1
            ],
            "details": "Migrar todas las etiquetas <img> a <Image> de Next.js. Configurar next.config.js con imageDomains. Implementar placeholder=\"blur\" o placeholder=\"empty\". Ajustar sizes, quality, y priority attributes. Crear custom Image component wrapper para consistencia",
            "status": "pending",
            "testStrategy": "Verificar lazy loading con Intersection Observer. Confirmar WebP format serving. Medir tamaño de imágenes optimizadas vs originales. Probar responsive images en diferentes viewports",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Configurar code splitting dinámico",
            "description": "Implementar carga de código bajo demanda para reducir bundle inicial",
            "dependencies": [
              1
            ],
            "details": "Implementar dynamic import() para componentes pesados. Configurar next/dynamic con loading skeletons. Separar vendor chunks y routes. Implementar bundle analyzer para identificar split opportunities. Ajustar webpack chunk splitting策略",
            "status": "pending",
            "testStrategy": "Medir bundle sizes antes y después. Probar carga de componentes dinámicos en DevTools. Verificar que chunk splitting funciona correctamente. Confirmar skeleton loading durante import",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implementar caching estratégico con stale-while-revalidate",
            "description": "Configurar headers de caching HTTP para recursos estáticos y API responses",
            "dependencies": [
              1
            ],
            "details": "Configurar Cache-Control headers para static assets (1 año max-age). Implementar stale-while-revalidate para assets que cambian raramente. Configurar CDN caching si aplica. Implementar service worker caching para recursos críticos. Optimizar fetch requests con proper caching headers",
            "status": "pending",
            "testStrategy": "Verificar headers en Network tab de DevTools. Probar caching behavior con tabs en modo incógnito. Confirmar stale-while-revalidate functionality con timestamp comparison",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Optimizar bundle y eliminar código no utilizado",
            "description": "Analizar y reducir tamaño del bundle eliminando código no utilizado y optimizando dependencias",
            "dependencies": [
              3
            ],
            "details": "Ejecutar bundle analyzer (webpack-bundle-analyzer). Identificar y eliminar dependencias duplicadas. Implementar tree shaking. Configurar sideEffects: false en package.json. Optimizar imports (named vs default). Reducir size de node_modules si aplica",
            "status": "pending",
            "testStrategy": "Comparar bundle sizes antes y después. Verificar que no hay broken references después de tree shaking. Probar que todas las funcionalidades funcionan correctamente",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Implementar minificación de CSS y JS",
            "description": "Configurar minificación agresiva para reducir tamaño de archivos de producción",
            "dependencies": [
              5
            ],
            "details": "Configurar CSS minification con cssnano. Implementar JS minificación con terser. Configurar compression para static assets. Optimizar critical CSS inlining. Eliminar CSS/JS no utilizados (PurgeCSS). Implementar minificación en tiempo de build",
            "status": "pending",
            "testStrategy": "Verificar minificación en producción. Comparar tamaños de archivos. Confirmar que toda funcionalidad funciona después de minificación. Probar source maps availability para debugging",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Implementar preload de recursos críticos",
            "description": "Identificar y pre cargar recursos esenciales para mejorar perceived performance",
            "dependencies": [
              4
            ],
            "details": "Identificar critical resources con Lighthouse. Implementar <link rel=\"preload\"> para fonts críticas. Preload imágenes above-the-fold. Preload CSS modules para initial paint. Implementar resource hints (prefetch, preconnect) para dominios externos. Optimizar priority hints",
            "status": "pending",
            "testStrategy": "Verificar preload en Network tab. Medir Resource Loading Time. Confirmar que critical resources se cargan antes que non-critical. Probar en slow 3G connection",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Optimizar Core Web Vitals",
            "description": "Implementar optimizaciones específicas para FCP, LCP, CLS, y FID",
            "dependencies": [
              2,
              7
            ],
            "details": "Optimizar FCP: minimizar render-blocking resources. Optimizar LCP: implementar hero image optimization, preload largest contentful paint elements. Optimizar CLS: implementar dimension placeholders, avoid layout shifts. Optimizar FID: minimize JavaScript execution time, implementar code splitting",
            "status": "pending",
            "testStrategy": "Medir Core Web Vitals con Web Vitals extension. Verificar LCP improvements. Confirmar CLS < 0.1. Medir FID/FID improvements. Probar con diferentes network conditions",
            "parentId": "undefined"
          },
          {
            "id": 9,
            "title": "Implementar Service Worker básico",
            "description": "Crear service worker para offline capability y caching inteligente",
            "dependencies": [
              4
            ],
            "details": "Crear service worker con runtime caching. Implementar offline fallback page. Cachear critical resources para offline access. Configurar cache update strategy. Implementar background sync si aplica. Registrar service worker correctamente",
            "status": "pending",
            "testStrategy": "Probar offline functionality. Verificar service worker registration. Probar cache invalidation. Confirmar fallbacks funcionan correctamente. Testear en Chrome DevTools Application tab",
            "parentId": "undefined"
          },
          {
            "id": 10,
            "title": "Validar y optimizar para Lighthouse score ≥90",
            "description": "Ejecutar auditorías finales y ajustes para alcanzar objetivo de performance",
            "dependencies": [
              8,
              9
            ],
            "details": "Ejecutar Lighthouse audit completo en desktop y móvil. Analizar opportunities y diagnostics. Implementar mejoras finales basadas en resultados. Optimizar TTFB (Time to First Byte). Configurar compression (gzip/brotli). Implementar proper error boundaries. Optimizar runtime performance con React.memo y useMemo",
            "status": "pending",
            "testStrategy": "Ejecutar Lighthouse final audit y verificar score ≥90. Probar en múltiples devices y network conditions. Confirmar Core Web Vitals thresholds. Realizar user testing en slow connections. Documentar métricas finales",
            "parentId": "undefined"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 10,
        "expansionPrompt": "Optimizar aplicación para Lighthouse score ≥90. Implementar Next.js Image para lazy loading automático. Code splitting dinámico. Caching estratégico con stale-while-revalidate. Bundle analysis para identificar oportunidades. Minificación CSS/JS. Preload critical resources. Service Worker para offline básico. Optimización Core Web Vitals."
      },
      {
        "id": "34",
        "title": "Implementar seguridad web y protección contra ataques",
        "description": "Asegurar aplicación contra XSS, CSRF, SQL Injection y otros ataques",
        "details": "Validación estricta con Zod en todos los inputs. Sanitización HTML con DOMPurify. Protección CSRF con tokens. Rate limiting configurable. Security headers (CSP, HSTS). SQL injection protection con RLS y queries parameterizadas. Penetration testing regular. Backup diario automático",
        "testStrategy": "Realizar pruebas de seguridad con OWASP ZAP, verificar headers de seguridad, probar inyección XSS, probar ataques CSRF, y verificar que backups funcionen",
        "priority": "high",
        "dependencies": [
          "33"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configurar validación estricta con Zod para todos los inputs",
            "description": "Implementar esquemas Zod para validar todos los datos de entrada del usuario, incluyendo parámetros URL, formularios y payloads API",
            "dependencies": [],
            "details": "Crear schemas Zod para email, passwords, usernames y otros datos. Implementar middleware de validación. Configurar mensajes de error específicos y en español",
            "status": "pending",
            "testStrategy": "Probar validación con inputs inválidos, verificar mensajes de error en español, testear casos edge como strings vacíos y caracteres especiales",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar sanitización XSS con DOMPurify",
            "description": "Instalar y configurar DOMPurify para limpiar todo contenido HTML dinámico y prevenir ataques XSS",
            "dependencies": [
              1
            ],
            "details": "Configurar DOMPurify con políticas estrictas. Implementar funciones de sanitización para contenido de usuario. Crear utilidades para diferentes contextos de renderizado",
            "status": "pending",
            "testStrategy": "Probar inyección XSS con payloads comunes, verificar que scripts maliciosos sean eliminados, testear con diferentes configuraciones DOMPurify",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Configurar protección CSRF con tokens",
            "description": "Implementar middleware CSRF tokens y sincronización entre cliente y servidor",
            "dependencies": [
              1
            ],
            "details": "Generar tokens CSRF únicos por sesión. Implementar verificación en endpoints POST/PUT/DELETE. Sincronizar tokens con frontend JavaScript",
            "status": "pending",
            "testStrategy": "Simular ataques CSRF sin tokens, probar verificación con tokens válidos/inválidos, testear en diferentes endpoints de API",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implementar rate limiting configurable",
            "description": "Crear sistema de limitación de peticiones para prevenir ataques de fuerza bruta y DoS",
            "dependencies": [
              1
            ],
            "details": "Configurar rate limiting por IP y usuario. Implementar diferentes límites para endpoints específicos. Crear sistema de bloqueo temporal",
            "status": "pending",
            "testStrategy": "Probar límites de peticiones por IP, testear diferentes umbrales de rate limiting, verificar bloqueo temporal y mensajes de error",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Configurar security headers (CSP, HSTS)",
            "description": "Implementar headers de seguridad críticos en configuración de servidor/Next.js",
            "dependencies": [],
            "details": "Configurar Content-Security-Policy estricto. Implementar HSTS con preload. Agregar X-Frame-Options, X-Content-Type-Options",
            "status": "pending",
            "testStrategy": "Verificar headers con browser DevTools, probar CSP con herramientas online, testear HSTS redirección, validar todos los headers de seguridad",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Implementar protección SQL Injection con RLS",
            "description": "Configurar Row Level Security en Supabase y usar queries parametrizadas",
            "dependencies": [],
            "details": "Crear políticas RLS para todas las tablas. Implementar queries parametrizadas en todo el código. Configurar autenticación con service role",
            "status": "pending",
            "testStrategy": "Intentar inyección SQL con payloads maliciosos, probar consultas con parámetros, testear políticas RLS con diferentes roles de usuario",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Configurar backup diario automático",
            "description": "Implementar sistema de backups automáticos de base de datos y archivos importantes",
            "dependencies": [
              6
            ],
            "details": "Configurar backups diarios de Supabase. Implementar retención de backups. Crear scripts de restauración. Configurar notificaciones de backup",
            "status": "pending",
            "testStrategy": "Probar proceso de backup automático, verificar restauración de datos, testear retención de backups, validar notificaciones de estado",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Implementar helmet.js para headers adicionales",
            "description": "Añadir protección adicional con helmet.js para headers HTTP",
            "dependencies": [
              5
            ],
            "details": "Instalar y configurar helmet.js. Ajustar configuración específica para la aplicación. Probar compatibilidad con el frontend",
            "status": "pending",
            "testStrategy": "Verificar headers adicionales con DevTools, probar navegación con diferentes configuraciones de helmet, testear compatibilidad cross-browser",
            "parentId": "undefined"
          },
          {
            "id": 9,
            "title": "Crear sistema de logging de eventos de seguridad",
            "description": "Implementar logging centralizado para eventos sospechosos y violaciones de seguridad",
            "dependencies": [
              1,
              3,
              4
            ],
            "details": "Configurar logging de intentos de ataque. Crear alertas para patrones sospechosos. Implementar dashboard de eventos de seguridad",
            "status": "pending",
            "testStrategy": "Simular eventos de seguridad, probar generación de logs, verificar alertas automáticas, testear dashboard de seguridad",
            "parentId": "undefined"
          },
          {
            "id": 10,
            "title": "Implementar pruebas de penetración automatizadas",
            "description": "Configurar OWASP ZAP u otras herramientas para testing regular de seguridad",
            "dependencies": [
              1,
              2,
              3,
              5,
              6
            ],
            "details": "Configurar OWASP ZAP para análisis automatizado. Crear scripts de testing de seguridad. Implementar reportes regulares de vulnerabilidades",
            "status": "pending",
            "testStrategy": "Ejecutar análisis completo con OWASP ZAP, probar detección de vulnerabilidades conocidas, verificar generación de reportes, testear configuración automatizada",
            "parentId": "undefined"
          },
          {
            "id": 11,
            "title": "Configurar autenticación de dos factores (2FA)",
            "description": "Implementar sistema de autenticación de dos factores para usuarios administrativos",
            "dependencies": [
              1,
              3
            ],
            "details": "Configurar 2FA con TOTP. Implementar backup codes. Crear interfaz de configuración de 2FA. Integrar con sistema de login existente",
            "status": "pending",
            "testStrategy": "Probar configuración de 2FA, testear login con y sin 2FA, verificar backup codes, probar recuperación de cuenta con 2FA",
            "parentId": "undefined"
          }
        ],
        "complexity": 9,
        "recommendedSubtasks": 11,
        "expansionPrompt": "Asegurar aplicación contra XSS, CSRF, SQL Injection y otros ataques. Validación estricta con Zod en todos los inputs. Sanitización HTML con DOMPurify. Protección CSRF con tokens. Rate limiting configurable. Security headers (CSP, HSTS). SQL injection protection con RLS y queries parameterizadas. Penetration testing regular. Backup diario automático."
      },
      {
        "id": "35",
        "title": "Implementar testing exhaustivo (Unit, Integration, E2E)",
        "description": "Crear suite de pruebas completa con Jest, React Testing Library y Playwright",
        "details": "Unit tests con Jest + React Testing Library (mínimo 80% coverage). Integration tests para API routes. E2E tests con Playwright para user journeys críticos. Visual regression testing. Testing de accesibilidad. Performance testing. CI/CD pipeline con tests automáticos",
        "testStrategy": "Ejecutar todos los tests y verificar coverage >80%, probar E2E journeys críticos, probar visual regression, verificar CI/CD pipeline, y validar testing de accesibilidad",
        "priority": "medium",
        "dependencies": [
          "34"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configurar Jest y React Testing Library",
            "description": "Instalar y configurar Jest con React Testing Library para el proyecto",
            "dependencies": [],
            "details": "Configurar jest.config.js, setupTests.js, y @testing-library/react para pruebas unitarias con soporte para TypeScript",
            "status": "pending",
            "testStrategy": "Verificar que Jest se ejecute correctamente y que las pruebas básicas de React funcionen",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Crear estructura de carpetas de pruebas",
            "description": "Organizar archivos de pruebas unitarias, de integración y fixtures",
            "dependencies": [
              1
            ],
            "details": "Crear carpetas __tests__, __mocks__, fixtures, y configurar paths en Jest para diferenciar tipos de pruebas",
            "status": "pending",
            "testStrategy": "Verificar estructura de archivos y configuración de paths en Jest",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar pruebas unitarias de componentes",
            "description": "Crear pruebas unitarias para todos los componentes React con cobertura mínima del 80%",
            "dependencies": [
              1,
              2
            ],
            "details": "Pruebas para componentes: renderizado, interacciones del usuario, cambios de estado, y comportamiento asíncrono con @testing-library/user-event",
            "status": "pending",
            "testStrategy": "Ejecutar pruebas unitarias y verificar cobertura ≥80% con Jest coverage report",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implementar pruebas unitarias de hooks y utilidades",
            "description": "Crear pruebas para hooks personalizados y funciones utilitarias",
            "dependencies": [
              1,
              2
            ],
            "details": "Pruebas de hooks con @testing-library/react-hooks y pruebas de funciones puras con Jest mocks para dependencias externas",
            "status": "pending",
            "testStrategy": "Verificar que todos los hooks personalizados tengan pruebas con diferentes casos de uso",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Configurar pruebas de integración para API routes",
            "description": "Implementar suite de pruebas para endpoints de API con Supabase",
            "dependencies": [
              3,
              4
            ],
            "details": "Configurar测试数据库环境 para pruebas de integración, crear mocks de Supabase, y probar todos los endpoints API",
            "status": "pending",
            "testStrategy": "Probar cada endpoint con casos de éxito, error y validación de datos",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Instalar y configurar Playwright",
            "description": "Configurar Playwright para pruebas E2E y regresión visual",
            "dependencies": [],
            "details": "Instalar @playwright/test, configurar playwright.config.ts, definir browsers (Chrome, Firefox, Safari) y modo headless/headed",
            "status": "pending",
            "testStrategy": "Verificar instalación con 'npx playwright test' y confirmar funcionamiento en todos los browsers",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Implementar pruebas E2E de user journeys críticos",
            "description": "Crear pruebas E2E para los flujos principales de la aplicación",
            "dependencies": [
              6
            ],
            "details": "Pruebas para: registro/login, navegación principal, CRUD operations, checkout process (si aplica), y flujos de búsqueda",
            "status": "pending",
            "testStrategy": "Ejecutar pruebas E2E en múltiples browsers y verificar que completan los journeys críticos sin errores",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Configurar pruebas de regresión visual",
            "description": "Implementar pruebas de regresión visual con Playwright",
            "dependencies": [
              6,
              7
            ],
            "details": "Configurar @playwright/visual-testing, definir puntos de control visuales para componentes críticos y páginas importantes",
            "status": "pending",
            "testStrategy": "Probar regresión visual y actualizar baseline después de cambios verificados",
            "parentId": "undefined"
          },
          {
            "id": 9,
            "title": "Implementar pruebas de accesibilidad",
            "description": "Integrar pruebas automatizadas de WCAG 2.1 AA con axe-core",
            "dependencies": [
              6,
              7
            ],
            "details": "Configurar @axe-core/playwright en pruebas E2E, crear pruebas específicas de navegación por teclado y pruebas con screen reader simulation",
            "status": "pending",
            "testStrategy": "Verificar cero violaciones de WCAG 2.1 AA con axe en todas las páginas principales",
            "parentId": "undefined"
          },
          {
            "id": 10,
            "title": "Configurar pipeline de CI/CD con pruebas automatizadas",
            "description": "Integrar todas las pruebas en pipeline de CI/CD",
            "dependencies": [
              3,
              5,
              8,
              9
            ],
            "details": "Configurar GitHub Actions o similar para ejecutar: unit tests (con coverage), integration tests, E2E tests, visual regression tests, y accesibilidad tests en cada PR",
            "status": "pending",
            "testStrategy": "Verificar pipeline completo se ejecuta exitosamente y genera reportes de cobertura y quality gates",
            "parentId": "undefined"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 10,
        "expansionPrompt": "Crear suite de pruebas completa con Jest, React Testing Library y Playwright. Unit tests con Jest + React Testing Library (mínimo 80% coverage). Integration tests para API routes. E2E tests con Playwright para user journeys críticos. Visual regression testing. Testing de accesibilidad. Performance testing. CI/CD pipeline con tests automáticos."
      },
      {
        "id": "36",
        "title": "Implementar responsive design avanzado",
        "description": "Refinar diseño responsive para óptima experiencia en todos los dispositivos",
        "details": "Optimizar breakpoints para dispositivos específicos. Touch states optimizados. Gesture support. Viewport meta tags. Responsive images con srcset. Responsive typography con fluid typography. Progressive enhancement. PWA básico con manifest.json. Offline support básico",
        "testStrategy": "Probar en múltiples dispositivos reales, verificar touch targets ≥44x44px, probar gestures, probar progressive enhancement, verificar PWA funciona, y validar offline support",
        "priority": "medium",
        "dependencies": [
          "2",
          "33"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configurar viewport meta tags y breakpoints base",
            "description": "Implementar meta tags de viewport y establecer breakpoints CSS responsive para diferentes tamaños de dispositivo",
            "dependencies": [],
            "details": "Añadir meta tag viewport en HTML principal. Definir breakpoints CSS: mobile (<480px), tablet (481-768px), desktop (769-1024px), large (>1024px). Configurar media queries con max-width y min-width apropiados",
            "status": "pending",
            "testStrategy": "Probar viewport inspector en diferentes dispositivos, verificar breakpoints con Chrome DevTools responsive tester",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar responsive images con srcset",
            "description": "Configurar imágenes responsivas que se adapten al dispositivo y tamaño de pantalla",
            "dependencies": [
              1
            ],
            "details": "Implementar atributo srcset en imágenes principales. Usar Next.js Image component para optimización automática. Definir tamaños de imagen responsive. Configurar formatos modernos (WebP, AVIF) con fallback JPEG",
            "status": "pending",
            "testStrategy": "Probar en diferentes tamaños de pantalla, verificar optimización de imágenes con Lighthouse, probar fallbacks",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar fluid typography responsive",
            "description": "Crear sistema de tipografía fluida que se adapte al viewport del usuario",
            "dependencies": [
              1
            ],
            "details": "Configurar unidades CSS clamp() para tamaños de letra fluidos. Definir escala tipográfica responsive (mobile: 16-18px, desktop: 18-21px). Implementar line-height responsive. Usar CSS custom properties para consistencia",
            "status": "pending",
            "testStrategy": "Probar escalado de texto en diferentes tamaños de viewport, verificar legibilidad a 200% zoom",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Optimizar touch states y gesture support",
            "description": "Mejorar experiencia táctil con estados optimizados y soporte de gestos",
            "dependencies": [
              1
            ],
            "details": "Implementar touch targets ≥44x44px. Añadir :active y :hover states táctiles. Configurar gestos básicos (swipe, tap). Implementar touch feedback visual. Usar CSS touch-action property apropiadamente",
            "status": "pending",
            "testStrategy": "Probar en dispositivos táctiles reales, verificar tamaño mínimo de touch targets con axe",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Crear PWA básica con manifest.json",
            "description": "Implementar Progressive Web App básica para mejor experiencia móvil",
            "dependencies": [
              1,
              2
            ],
            "details": "Crear manifest.json con name, short_name, icons, theme_color, background_color. Configurar Service Worker básico para caching. Implementar offline support para páginas críticas. Configurar install prompts",
            "status": "pending",
            "testStrategy": "Probar instalación PWA en Chrome, verificar funcionamiento offline, probar Lighthouse PWA audit",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Implementar progressive enhancement",
            "description": "Asegurar funcionalidad básica sin JavaScript y mejoras con JavaScript habilitado",
            "dependencies": [
              1,
              3
            ],
            "details": "Verificar navegación funcional sin JS. Implementar formularios que funcionen con server-side rendering. Añadir mejoras progresivas con JavaScript (autocompletado, validación en tiempo real). Usar feature detection con Modernizr o similar",
            "status": "pending",
            "testStrategy": "Probar con JavaScript deshabilitado, verificar funcionalidad básica, probar mejoras con JS activado",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Implementar offline support avanzado",
            "description": "Extender soporte offline con caché inteligente y gestión de estado",
            "dependencies": [
              5
            ],
            "details": "Configurar Service Worker con caché de recursos críticos. Implementar estrategia caché-first/network-fallback. Añadir gestión de estado offline/online. Configurar sync background para actualizaciones. Implementar manejo de errores de red",
            "status": "pending",
            "testStrategy": "Probar funcionamiento completo offline, verificar sincronización al volver online, probar errores de red",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 7,
        "expansionPrompt": "Refinar diseño responsive para óptima experiencia en todos los dispositivos. Optimizar breakpoints para dispositivos específicos. Touch states optimizados. Gesture support. Viewport meta tags. Responsive images con srcset. Responsive typography con fluid typography. Progressive enhancement. PWA básico con manifest.json. Offline support básico."
      },
      {
        "id": "37",
        "title": "Implementar accesibilidad WCAG 2.1 AA",
        "description": "Asegurar cumplimiento completo de estándares de accesibilidad",
        "details": "Colores con contraste suficiente (4.5:1 mínimo). Navegación por teclado completa. Screen reader support con ARIA labels. Alt text descriptivo en imágenes. Forms con labels asociados. Focus management. Skip links. Resize text 200% sin romper layout. Testing con axe DevTools y screen readers reales",
        "testStrategy": "Probar con axe DevTools (cero errores), probar navegación por teclado, probar con screen reader (NVDA/JAWS), probar resize text 200%, y validar ARIA labels",
        "priority": "medium",
        "dependencies": [
          "36"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Auditar estado actual de accesibilidad",
            "description": "Realizar auditoría completa con axe DevTools para identificar problemas WCAG 2.1 AA existentes en la aplicación",
            "dependencies": [],
            "details": "Instalar y configurar axe DevTools. Ejecutar auditoría completa en todas las páginas del sitio. Documentar todos los errores y advertencias encontradas. Priorizar problemas por severidad según WCAG 2.1 AA. Crear checklist de accesibilidad actual.",
            "status": "pending",
            "testStrategy": "Verificar que axe DevTools genere reporte completo, validar que todas las páginas hayan sido auditadas, confirmar que se hayan capturado screenshots de los problemas, y probar la exportación del reporte de accesibilidad",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar contraste de colores WCAG 4.5:1",
            "description": "Ajustar colores de texto y fondos para cumplir con ratio de contraste mínimo de 4.5:1 según WCAG 2.1 AA",
            "dependencies": [
              1
            ],
            "details": "Analizar esquema de colores actual con herramientas de contraste. Identificar todos los elementos que no cumplen el ratio 4.5:1. Diseñar nueva paleta de colores accesible. Implementar cambios en CSS/Sass/variables. Probar en modo oscuro/claro. Validar con verificador de contraste W3C.",
            "status": "pending",
            "testStrategy": "Verificar contraste con herramientas online (WebAIM, Coolors), probar con simulador de daltonismo, validar en diferentes navegadores y dispositivos, y confirmar que funcione con modos alto contraste del sistema operativo",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar navegación completa por teclado",
            "description": "Asegurar que toda la funcionalidad del sitio sea accesible y navegable utilizando únicamente el teclado",
            "dependencies": [
              2
            ],
            "details": "Revisar todos los elementos interactivos para asegurarse que sean focusable. Implementar tab order lógico. Asegurar que todos los botones y links se puedan activar con Enter/Space. Agregar estilos visibles para focus. Implementar skip links para saltar contenido repetitivo. Probar navegación con Tab, Shift+Tab, Enter, Space, Arrow keys.",
            "status": "pending",
            "testStrategy": "Probar navegación completa sin usar mouse, verificar que todos los elementos interactivos reciban focus, confirmar que los estilos de focus sean visibles, probar con usuarios avanzados que usan solo teclado, y validar en diferentes dispositivos",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implementar ARIA labels y semantic HTML",
            "description": "Agregar etiquetas ARIA apropiadas y HTML semántico para mejorar la experiencia con screen readers",
            "dependencies": [
              3
            ],
            "details": "Analizar estructura HTML actual para identificar necesidades semánticas. Reemplazar divs por elementos apropiados (nav, main, section, etc.). Agregar aria-labels, aria-describedby, aria-expanded. Implementar landmarks con ARIA roles. Configurar aria-live regions para contenido dinámico. Agregar aria-hidden a elementos decorativos.",
            "status": "pending",
            "testStrategy": "Probar con NVDA/JAWS/VoiceOver, validar estructura de página con screen reader, verificar que todos los formularios tengan labels asociados, probar con navegación por headings/landmarks, y confirmar que aria-live regions funcionen correctamente",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implementar alt text descriptivo y gestión de imágenes",
            "description": "Asegurar que todas las imágenes tengan texto alternativo apropiado según su contenido y propósito",
            "dependencies": [
              4
            ],
            "details": "Auditar todas las imágenes del sitio para identificar alt text faltante. Crear guías para alt text descriptivo según contexto de la imagen. Implementar alt text para imágenes informativas. Usar alt='' para imágenes decorativas. Agregar longdesc para imágenes complejas. Configurar lazy loading accesible. Implementar figcaption para figuras.",
            "status": "pending",
            "testStrategy": "Verificar con screen reader que todas las imágenes tengan descripción apropiada, probar con imágenes deshabilitadas, validar que alt text sea descriptivo y no redundante, confirmar que imágenes decorativas sean ignoradas, y probar figcaption con imágenes complejas",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Implementar focus management y formularios accesibles",
            "description": "Optimizar gestión de foco y asegurar que todos los formularios sean completamente accesibles",
            "dependencies": [
              5
            ],
            "details": "Implementar labels correctamente asociadas con for/id. Agregar fieldsets y legends para grupos de formularios. Configurar focus trapping en modales y diálogos. Implementar indicadores de error accesibles. Agregar descripciones de ayuda con aria-describedby. Configurar autofocus apropiado. Implementar validación accesible.",
            "status": "pending",
            "testStrategy": "Probar validación de formularios con screen reader, verificar que labels estén correctamente asociados, probar focus trapping en modales, validar indicadores de error, confirmar navegación por campos del formulario, y probar envío con teclado",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Implementar responsive design y resize text 200%",
            "description": "Asegurar que el diseño funcione correctamente con zoom de texto hasta 200% sin romper el layout",
            "dependencies": [
              6
            ],
            "details": "Analizar comportamiento actual con zoom de navegador y resize text del navegador. Implementar unidades relativas (rem, em, %, vw/vh). Configurar breakpoints apropiados. Asegurar que contenido no se desborde. Optimizar para touch en dispositivos móviles. Implementar scroll horizontal solo cuando es necesario. Probar en diferentes tamaños de pantalla.",
            "status": "pending",
            "testStrategy": "Probar zoom del navegador al 200%, verificar que no haya scroll horizontal, probar con configuraciones de accesibilidad del sistema operativo, validar en diferentes resoluciones de pantalla, confirmar que todo el contenido siga accesible, y probar con diferentes densidades de píxeles",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Validación final de accesibilidad WCAG 2.1 AA",
            "description": "Realizar pruebas exhaustivas finales para validar cumplimiento completo de WCAG 2.1 AA",
            "dependencies": [
              7
            ],
            "details": "Ejecutar auditoría completa con axe DevTools para confirmar cero errores. Probar con múltiples screen readers (NVDA, JAWS, VoiceOver). Realizar pruebas de navegación por teclado exhaustivas. Validar con herramientas automatizadas (WAVE, Lighthouse accessibility). Probar con usuarios reales con discapacidades. Crear documentación de accesibilidad. Configurar reportes periódicos.",
            "status": "pending",
            "testStrategy": "Ejecutar suite completa de pruebas automatizadas, realizar pruebas manuales con screen readers, validar con herramientas de terceros, probar con usuarios reales, verificar Lighthouse accessibility score ≥95, y crear documentación de mantenimiento",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 8,
        "expansionPrompt": "Asegurar cumplimiento completo de estándares WCAG 2.1 AA. Colores con contraste suficiente (4.5:1 mínimo). Navegación por teclado completa. Screen reader support con ARIA labels. Alt text descriptivo en imágenes. Forms con labels asociados. Focus management. Skip links. Resize text 200% sin romper layout. Testing con axe DevTools y screen readers reales."
      },
      {
        "id": "38",
        "title": "Implementar optimización de base de datos avanzada",
        "description": "Optimizar queries PostgreSQL e implementar caching",
        "details": "Analizar queries lentos con EXPLAIN. Índices compuestos para búsquedas complejas. Materialized views para reportes complejos. Connection pooling optimizado. Query results caching con Redis (opcional). Database partitioning por fecha si es necesario. Monitor de performance de queries",
        "testStrategy": "Analizar performance de queries principales, probar materialized views, verificar connection pooling, medir tiempo de respuesta antes y después de optimización, y probar cache effectiveness",
        "priority": "medium",
        "dependencies": [
          "14",
          "33"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Analizar queries lentas con EXPLAIN y optimizarlas",
            "description": "Identificar las consultas más lentas y utilizar EXPLAIN ANALYZE para entender su plan de ejecución",
            "dependencies": [],
            "details": "Ejecutar consultas SELECT de prueba en tablas principales con EXPLAIN ANALYZE, identificar full table scans, nested loops costosos y seq scans. Documentar queries prioritarias por optimización basadas en frecuencia de uso y tiempo de ejecución",
            "status": "pending",
            "testStrategy": "Crear benchmark de queries antes/después, medir tiempos de ejecución, verificar planes optimizados",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Crear índices compuestos para búsquedas complejas",
            "description": "Diseñar e implementar índices multicolumna basados en patrones de consultas identificados",
            "dependencies": [
              1
            ],
            "details": "Crear índices compuestos en columnas WHERE, JOIN y ORDER BY comúnmente usadas. Usar índices parciales con INCLUDE para columnas SELECT frecuentes. Considerar índices tipo BRIN para datos por fecha si aplica",
            "status": "pending",
            "testStrategy": "Verificar uso de índices con EXPLAIN, comparar tiempos de ejecución, probar consultas con y sin índices",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar vistas materializadas para reportes complejos",
            "description": "Crear vistas materializadas para consultas complejas y reportes频繁mente utilizados",
            "dependencies": [
              1,
              2
            ],
            "details": "Identificar reportes y dashboards con consultas complejas. Crear vistas materializadas con REFRESH MATERIALIZED CONCURRENTLY. Establecer cron jobs para actualización periódica de vistas basadas en frescura de datos requerida",
            "status": "pending",
            "testStrategy": "Medir tiempos de carga de reportes antes/después, verificar actualización correcta de datos, probar concurrencia durante refresh",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Optimizar connection pooling en la aplicación",
            "description": "Configurar y optimizar pool de conexiones PostgreSQL para mejor rendimiento",
            "dependencies": [],
            "details": "Configurar PgBouncer o similar con settings óptimos (max_connections, pool_mode, server_reset_query). Ajustar timeouts de conexión y idle connection management. Implementar connection pooling en aplicación si no existe",
            "status": "pending",
            "testStrategy": "Simular carga concurrente, monitorar conexiones activas, medir latencia de conexión bajo carga",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implementar cache de resultados de consultas con Redis",
            "description": "Configurar sistema de caché para resultados de consultas frecuentes",
            "dependencies": [
              1,
              2
            ],
            "details": "Implementar Redis para caché de consultas. Crear sistema de cache keys basadas en hash de consulta. Implementar TTL adecuado por tipo de dato. Configurar cache invalidation策略. Considerar query result caching versus object level caching",
            "status": "pending",
            "testStrategy": "Medir cache hit ratio, probar cache invalidation, comparar tiempos de respuesta con/ sin cache",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Implementar database partitioning por fecha si es necesario",
            "description": "Evaluar y configurar particionamiento de tablas por fecha para mejorar rendimiento",
            "dependencies": [
              1,
              2
            ],
            "details": "Analizar tablas con crecimiento temporal significativo (logs, eventos, datos históricos). Implementar particionamiento por rango de fechas (range partitioning). Configurar particiones automáticas futuras. Optimizar queries para partition pruning",
            "status": "pending",
            "testStrategy": "Verificar partition pruning en EXPLAIN, medir performance en consultas temporales, probar mantenimiento de particiones",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Configurar monitor de performance de consultas",
            "description": "Implementar sistema completo de monitoreo para métricas de base de datos",
            "dependencies": [
              1,
              2,
              3,
              4,
              5,
              6
            ],
            "details": "Configurar pg_stat_statements extension. Implementar dashboard de métricas (query count, mean_time, rows). Configurar alertas para queries anómalas. Integrar con sistema de monitoreo general (Sentry/Grafana). Establecer KPIs de performance",
            "status": "pending",
            "testStrategy": "Verificar recolección de métricas, probar alertas, validar dashboard, testear integración con monitoring existente",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 7,
        "expansionPrompt": "Optimizar queries PostgreSQL e implementar caching. Analizar queries lentos con EXPLAIN. Índices compuestos para búsquedas complejas. Materialized views para reportes complejos. Connection pooling optimizado. Query results caching con Redis (opcional). Database partitioning por fecha si es necesario. Monitor de performance de queries."
      },
      {
        "id": "39",
        "title": "Implementar monitoring y logging",
        "description": "Configurar sistema completo de monitoreo y logging",
        "details": "Error tracking con Sentry. Performance monitoring con Vercel Analytics. Custom metrics para KPIs específicos. Structured logging. Alert configurado para errores críticos. Uptime monitoring. Database performance monitoring. User behavior tracking con GA4",
        "testStrategy": "Probar que errores se capturen en Sentry, verificar performance metrics, probar alerting, verificar uptime monitoring, y configurar dashboard de monitoreo",
        "priority": "medium",
        "dependencies": [
          "34"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configurar Sentry para error tracking",
            "description": "Implementar Sentry para capturar y monitorear errores en la aplicación",
            "dependencies": [],
            "details": "Instalar @sentry/nextjs, configurar DSN, setup de error boundaries, integración con middleware para capturar errores de servidor y cliente",
            "status": "pending",
            "testStrategy": "Verificar que los errores se capturen correctamente en dashboard de Sentry, probar notificaciones de error",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar structured logging",
            "description": "Configurar sistema de logs estructurados para mejor trazabilidad",
            "dependencies": [],
            "details": "Setup de Winston o pino para structured logging, configurar niveles de log, implementar context metadata, setup de log rotation",
            "status": "pending",
            "testStrategy": "Verificar formatos de logs estructurados, probar diferentes niveles de log, validar rotación de logs",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Configurar Vercel Analytics para performance monitoring",
            "description": "Implementar Vercel Analytics para monitorear métricas de rendimiento",
            "dependencies": [],
            "details": "Instalar @vercel/analytics, configurar trackings personalizados, setup de Web Vitals, implementar custom events para KPIs específicos",
            "status": "pending",
            "testStrategy": "Verificar que las métricas se registren correctamente en Vercel dashboard, probar custom events",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implementar uptime monitoring",
            "description": "Configurar sistema de monitoreo de disponibilidad del servicio",
            "dependencies": [
              1
            ],
            "details": "Configurar UptimeRobot o Pingdom, setup de health checks endpoints, configurar notificaciones de downtime, implementar status page",
            "status": "pending",
            "testStrategy": "Probar health check endpoints, verificar notificaciones de downtime, testear alerting configuration",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Configurar database performance monitoring",
            "description": "Implementar monitoreo específico para rendimiento de base de datos",
            "dependencies": [],
            "details": "Configurar pg_stat_statements para PostgreSQL, implementar query logging, setup de slow query alerts, monitor de conexión pools",
            "status": "pending",
            "testStrategy": "Verificar captura de slow queries, probar métricas de performance de DB, validar alerts configurados",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Implementar GA4 para user behavior tracking",
            "description": "Configurar Google Analytics 4 para tracking de comportamiento de usuarios",
            "dependencies": [],
            "details": "Instalar gtag, configurar pageviews tracking, implementar custom events para acciones específicas, setup de conversion goals",
            "status": "pending",
            "testStrategy": "Verificar pageviews en GA4, probar custom events, validar que los datos lleguen correctamente a Google Analytics",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Configurar dashboard de monitoreo y alerting",
            "description": "Crear dashboard centralizado y configurar alertas críticas",
            "dependencies": [
              1,
              2,
              3,
              4,
              5,
              6
            ],
            "details": "Crear dashboard en Grafana o similar, configurar alertas para errores críticos, setup de Slack/Email notifications, definir umbrales de rendimiento",
            "status": "pending",
            "testStrategy": "Probar funcionamiento del dashboard, verificar alertas configuradas, testear canales de notificación",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 7,
        "expansionPrompt": "Configurar sistema completo de monitoreo y logging. Error tracking con Sentry. Performance monitoring con Vercel Analytics. Custom metrics para KPIs específicos. Structured logging. Alert configurado para errores críticos. Uptime monitoring. Database performance monitoring. User behavior tracking con GA4."
      },
      {
        "id": "40",
        "title": "Implementar PWA y capacidades offline",
        "description": "Crear Progressive Web App con funcionalidad offline básica",
        "details": "Manifest.json con iconos PWA. Service Worker para caché de recursos críticos. Offline fallback page. Background sync para acciones pendientes. Push notifications (preparación para fase 2). Install prompt personalizado. App shell architecture. Cache-first strategy",
        "testStrategy": "Probar instalación PWA, probar funcionalidad offline, verificar service worker funciona, probar background sync, y validar Lighthouse PWA score",
        "priority": "low",
        "dependencies": [
          "36",
          "37"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear archivo manifest.json con configuración PWA",
            "description": "Configurar el archivo manifest.json con datos de la aplicación, iconos y capacidades de instalación",
            "dependencies": [],
            "details": "Crear manifest.json con nombre, descripción, iconos en múltiples tamaños (72x72, 96x96, 128x128, 144x144, 152x152, 192x192, 384x384, 512x512), colores de tema, pantalla de inicio y orientación preferida",
            "status": "pending",
            "testStrategy": "Validar JSON contra especificación de Web App Manifest, probar instalación PWA en Chrome/Edge, verificar iconos cargan correctamente",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar Service Worker básico con estrategia cache-first",
            "description": "Crear Service Worker para interceptar peticiones de red y proporcionar funcionalidad offline",
            "dependencies": [
              1
            ],
            "details": "Implementar Service Worker con eventos install, activate, fetch. Configurar cache-first strategy para recursos críticos (HTML, CSS, JS estáticos). Network-first strategy para llamadas API. Stale-while-revalidate para contenido dinámico",
            "status": "pending",
            "testStrategy": "Probar Service Worker registration, verificar caché de recursos estáticos, probar funcionalidad offline, validar update mechanism",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Crear offline fallback page con app shell architecture",
            "description": "Diseñar página offline funcional que brinde experiencia básica cuando no hay conexión",
            "dependencies": [
              2
            ],
            "details": "Crear HTML fallback con shell básico de la aplicación. Incluir navegación offline-aware. Mostrar sincronización pendiente. Botones para reintentar conexión. Estilo consistente con app online",
            "status": "pending",
            "testStrategy": "Probar navegación offline, verificar UI funcional sin conexión, comprobar que shell se carga correctamente, probar reintentos de conexión",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implementar sistema de background sync para acciones pendientes",
            "description": "Crear mecanismo para almacenar y sincronizar acciones cuando la conexión retorna",
            "dependencies": [
              3
            ],
            "details": "Usar Background Sync API con fallback a IndexedDB. Cola de acciones CRUD pendientes. UI indicador de sincronización. Recuperación automática al reestablecer conexión. Manejo de conflictos de sincronización",
            "status": "pending",
            "testStrategy": "Probar almacenamiento offline de acciones, verificar sincronización automática al volver online, probar manejo de fallos de sincronización, validar UI de estado de sincronización",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Configurar PWA install prompt y registrar Service Worker en app",
            "description": "Integrar capacidades PWA en la aplicación existente con prompt de instalación personalizado",
            "dependencies": [
              4
            ],
            "details": "Añadir Service Worker registration en código principal. Implementar install prompt con beforeinstallprompt event. Botón de instalación personalizado con UI atractiva. Manejar appinstalled event para tracking. Configurar display mode standalone",
            "status": "pending",
            "testStrategy": "Probar prompt de instalación en Chrome, verificar instalación como app nativa, comprobar funcionamiento offline post-instalación, validar tracking de eventos de instalación",
            "parentId": "undefined"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Crear Progressive Web App con funcionalidad offline básica. Manifest.json con iconos PWA. Service Worker para caché de recursos críticos. Offline fallback page. Background sync para acciones pendientes. Push notifications (preparación para fase 2). Install prompt personalizado. App shell architecture. Cache-first strategy."
      },
      {
        "id": "41",
        "title": "Configurar documentación técnica y API",
        "description": "Crear documentación completa para desarrolladores y API",
        "details": "OpenAPI 3.0 specification con Swagger UI. Documentación de componentes con Storybook. Guías de contribución. Database schema documentation. Deployment guide. README completo con setup instructions. API examples en Postman collection",
        "testStrategy": "Verificar Swagger UI funciona, probar documentación de componentes, validar que examples funcionen, probar setup guide desde cero, y verificar Postman collection",
        "priority": "medium",
        "dependencies": [
          "35"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear especificación OpenAPI 3.0 para endpoints principales",
            "description": "Desarrollar documentación OpenAPI 3.0 completa para todos los endpoints de la API REST del proyecto ESET-Noti",
            "dependencies": [],
            "details": "Analizar rutas existentes en Next.js y crear especificación YAML/JSON con schemas, parámetros, respuestas y códigos de error. Incluir autenticación JWT",
            "status": "pending",
            "testStrategy": "Validar esquema contra OpenAPI 3.0 specification, probar con swagger-ui",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar Swagger UI integrado en el proyecto",
            "description": "Configurar swagger-ui-react para visualización interactiva de la API documentation",
            "dependencies": [
              1
            ],
            "details": "Instalar swagger-ui-react, crear página /api/docs, configurar tema personalizado ESET, y conectar con especificación OpenAPI",
            "status": "pending",
            "testStrategy": "Verificar UI funciona en diferentes dispositivos, probar 'Try it out' con endpoints reales",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Configurar Storybook para documentación de componentes",
            "description": "Establecer Storybook v7 para documentación visual y interactiva de componentes React",
            "dependencies": [],
            "details": "Instalar @storybook/nextjs v7, configurar addons para docs, controles y accesibilidad. Crear stories para componentes principales",
            "status": "pending",
            "testStrategy": "Verificar Storybook inicia correctamente, probar todos los stories, validar documentación visual",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Documentar esquema de base de datos Supabase",
            "description": "Crear documentación completa del schema PostgreSQL con diagramas y relaciones",
            "dependencies": [],
            "details": "Usar Supabase database documentation, generar diagramas ER, documentar tablas, columnas, tipos y restricciones. Incluir RLS policies",
            "status": "pending",
            "testStrategy": "Verificar documentación coincide con schema real, probar consultas de ejemplo",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Crear guías de contribución y deployment",
            "description": "Desarrollar documentación completa para desarrolladores y guía de deployment",
            "dependencies": [
              3,
              4
            ],
            "details": "Crear CONTRIBUTING.md con estándares de código, ISSUE_TEMPLATE.md, y deployment guide con Vercel. Incluir troubleshooting común",
            "status": "pending",
            "testStrategy": "Seguir guía desde cero, verificar deployment, probar templates de issues",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Crear README completo y Postman collection",
            "description": "Desarrollar README principal y colección Postman con ejemplos de API",
            "dependencies": [
              2,
              5
            ],
            "details": "Escribir README con arquitectura, setup local, y documentación. Crear Postman collection con environment variables y ejemplos de workflows",
            "status": "pending",
            "testStrategy": "Probar setup desde README usando las instrucciones, importar y probar Postman collection",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 6,
        "expansionPrompt": "Crear documentación completa para desarrolladores y API. OpenAPI 3.0 specification con Swagger UI. Documentación de componentes con Storybook. Guías de contribución. Database schema documentation. Deployment guide. README completo con setup instructions. API examples en Postman collection."
      },
      {
        "id": "42",
        "title": "Implementar internacionalización (i18n)",
        "description": "Preparar sistema para soportar múltiples idiomas en el futuro",
        "details": "Setup next-i18next o similar. Español como idioma por defecto. Estructura para inglés en el futuro. Separación de contenido de UI. Lazy loading de traducciones. Formato de fechas localizadas. Números localizados. Testing de RTL readiness (para futuros idiomas RTL)",
        "testStrategy": "Probar español funciona correctamente, preparar estructura para inglés, probar lazy loading de traducciones, verificar formatos localizados, y validar readiness para futuro i18n",
        "priority": "low",
        "dependencies": [
          "6"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configurar sistema i18n con next-i18next",
            "description": "Instalar y configurar next-i18next con español como idioma predeterminado, preparar estructura para inglés futuro",
            "dependencies": [],
            "details": "Instalar next-i18next y react-i18next, configurar i18n.js con español como default, crear estructura de carpetas locales/es y futura locales/en, configurar middleware para locale detection",
            "status": "pending",
            "testStrategy": "Verificar que español se muestre correctamente, probar switch de idioma con fallback, validar configuración de rutas con locale",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar separación de contenido UI con lazy loading",
            "description": "Crear sistema de traducción con lazy loading para componentes y contenido dinámico",
            "dependencies": [
              1
            ],
            "details": "Implementar useTranslation hooks, crear archivos JSON de traducción por componentes, configurar lazy loading de namespaces, implementar fallbacks para traducciones faltantes",
            "status": "pending",
            "testStrategy": "Probar renderizado correcto con traducciones, verificar lazy loading de namespaces, probar fallback cuando faltan traducciones",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar formatos localizados para fechas y números",
            "description": "Crear sistema de formateo localizado para fechas, monedas y números según idioma",
            "dependencies": [
              1
            ],
            "details": "Configurar Intl.NumberFormat y Intl.DateTimeFormat, crear utilitarios para formateo de monedas, fechas y números, implementar timezone handling, crear componentes para formateo localizado",
            "status": "pending",
            "testStrategy": "Probar formateo de fechas en diferentes formatos, verificar números con separadores locales, probar monedas con símbolos correctos",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Preparar estructura para idiomas RTL y testing de readiness",
            "description": "Configurar sistema CSS y estructura para soportar idiomas RTL en futuro, crear tests de readiness",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Implementar CSS logical properties, configurar dir attribute dinámico, crear utilitarios de RTL detection, setup tests para validación RTL, preparar hooks para dirección de texto",
            "status": "pending",
            "testStrategy": "Probar cambio de dirección de texto, verificar CSS logical properties funcionan, probar readiness para idiomas RTL, validar accesibilidad con RTL",
            "parentId": "undefined"
          }
        ],
        "complexity": 3,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Preparar sistema para soportar múltiples idiomas en el futuro. Setup next-i18next o similar. Español como idioma por defecto. Estructura para inglés en el futuro. Separación de contenido de UI. Lazy loading de traducciones. Formato de fechas localizadas. Números localizados. Testing de RTL readiness (para futuros idiomas RTL)."
      },
      {
        "id": "43",
        "title": "Implementar sistema de backup y recovery",
        "description": "Crear estrategia completa de backup y recuperación",
        "details": "Backup diario automático de base de datos (Supabase ya lo provee). Backup de imágenes en Storage con retención de 30 días. Export regular de contenido. Documentación de recovery procedures. Testing regular de backups. DR (Disaster Recovery) plan básico. Point-in-time recovery capability",
        "testStrategy": "Verificar backups automáticos funcionen, probar recovery procedure, probar export/import de contenido, validar retención de 30 días, y probar DR plan",
        "priority": "medium",
        "dependencies": [
          "38"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configurar backup automático de base de datos con Supabase",
            "description": "Implementar sistema de backups diarios automáticos para la base de datos utilizando las capacidades nativas de Supabase",
            "dependencies": [],
            "details": "Configurar backup diario automático en panel de Supabase, establecer retención de backups por 30 días, documentar procedimiento de configuración y crear monitoreo para verificar que los backups se ejecuten correctamente",
            "status": "pending",
            "testStrategy": "Verificar que los backups diarios se ejecuten correctamente en el panel de Supabase, probar restauración de base de datos desde backup, validar retención de 30 días",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar backup de imágenes en Supabase Storage",
            "description": "Crear sistema de backup para todas las imágenes almacenadas en Supabase Storage con políticas de retención",
            "dependencies": [],
            "details": "Desarrollar script para backup de imágenes desde Storage, configurar retención de 30 días, implementar compresión de imágenes para optimizar espacio de almacenamiento, y crear procedimiento de recuperación",
            "status": "pending",
            "testStrategy": "Probar backup completo de todas las imágenes, verificar que archivos se puedan recuperar correctamente, validar compresión y retención de 30 días",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Crear sistema de exportación regular de contenido",
            "description": "Implementar exportación programada de todo el contenido de la aplicación en formatos estructurados",
            "dependencies": [
              1
            ],
            "details": "Desarrollar función para exportar artículos, usuarios y configuraciones en formato JSON/XML, crear cron job para exportaciones semanales, implementar sistema de versionamiento para exports, y almacenar exports en ubicación segura",
            "status": "pending",
            "testStrategy": "Verificar que el contenido se exporte completamente, probar importación desde archivo de exportación, validar integridad de datos exportados",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Documentar procedimientos de recovery",
            "description": "Crear documentación completa detallada paso a paso para recuperación de todos los sistemas",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Escribir guía detallada para recuperación de base de datos, documentar procedimiento de recuperación de imágenes, crear checklist para recovery completo, incluir screenshots y ejemplos, y documentar point-in-time recovery",
            "status": "pending",
            "testStrategy": "Probar que la documentación sea comprensible y completa, ejecutar recovery simulado siguiendo la documentación, validar que todos los pasos funcionen correctamente",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implementar testing regular de backups y DR plan",
            "description": "Crear sistema automatizado de testing de backups y plan básico de disaster recovery",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Desarrollar script automatizado para testing mensual de backups, crear procedimiento de disaster recovery básico, implementar monitoreo continuo de salud de backups, definir roles y responsabilidades en emergencias, y crear plan de comunicación para incidentes",
            "status": "pending",
            "testStrategy": "Ejecutar testing automatizado de backups, probar plan de disaster recovery en ambiente de pruebas, verificar que todos los sistemas se puedan recuperar exitosamente",
            "parentId": "undefined"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Crear estrategia completa de backup y recuperación. Backup diario automático de base de datos (Supabase ya lo provee). Backup de imágenes en Storage con retención de 30 días. Export regular de contenido. Documentación de recovery procedures. Testing regular de backups. DR (Disaster Recovery) plan básico. Point-in-time recovery capability."
      },
      {
        "id": "44",
        "title": "Implementar SEO optimización",
        "description": "Optimizar aplicación para motores de búsqueda",
        "details": "Meta tags optimizadas con Open Graph y Twitter Cards. Sitemap.xml generado automáticamente. Robots.txt configurado. Structured data con JSON-LD. URL canónicas y amigables. Page titles descriptivos. Meta descriptions únicas. Imágenes con alt text. Core Web Vitals optimizadas para SEO",
        "testStrategy": "Probar meta tags con herramientas SEO, verificar sitemap.xml funciona, probar structured data validation, verificar Core Web Vitals para SEO, y probar indexación en Google Search Console",
        "priority": "medium",
        "dependencies": [
          "33",
          "37"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implementar meta tags optimizadas (Open Graph y Twitter Cards)",
            "description": "Crear componentes para meta tags dinámicas con Open Graph y Twitter Cards en todas las páginas",
            "dependencies": [],
            "details": "Desarrollar componente SEOHead con meta tags dinámicas. Implementar Open Graph (title, description, image, url, type) y Twitter Cards (card, title, description, image). Integrar con layout principal y páginas específicas.",
            "status": "pending",
            "testStrategy": "Validar meta tags con Facebook Sharing Debugger y Twitter Card Validator. Probar en diferentes tipos de contenido.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Configurar sitemap.xml automático",
            "description": "Implementar generación automática de sitemap.xml para todas las páginas de la aplicación",
            "dependencies": [],
            "details": "Crear script para generar sitemap.xml dinámicamente. Incluir todas las páginas estáticas y dinámicas. Configurar frecuencia de actualización y prioridad. Integrar con Next.js routes.",
            "status": "pending",
            "testStrategy": "Verificar sitemap.xml generado contiene todas las URLs. Probar validación XML. Confirmar indexación en Google Search Console.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Configurar robots.txt optimizado",
            "description": "Crear y configurar archivo robots.txt para controlar el acceso de crawlers",
            "dependencies": [],
            "details": "Crear robots.txt personalizado. Incluir User-agent para Googlebot, Bingbot, etc. Permitir acceso a recursos importantes. Bloquear rutas privadas y duplicadas.",
            "status": "pending",
            "testStrategy": "Probar robots.txt con Google robots.txt tester. Verificar que no bloquee contenido importante y proteja rutas sensibles.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implementar structured data con JSON-LD",
            "description": "Añadir structured data en formato JSON-LD para mejorar la comprensión de contenido",
            "dependencies": [],
            "details": "Implementar JSON-LD para WebSite, Organization, Article, BreadcrumbList, y otros tipos relevantes. Crear componentes reutilizables. Integrar datos dinámicos del contenido.",
            "status": "pending",
            "testStrategy": "Validar structured data con Google Rich Results Test. Probar diferentes tipos de contenido. Verificar renderizado correcto.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Optimizar URLs canónicas y amigables",
            "description": "Implementar URLs amigables y canónicas con redirecciones automáticas",
            "dependencies": [],
            "details": "Configurar rutas amigables en Next.js. Implementar canónical tags para contenido duplicado. Asegurar consistencia en URL structure. Manejar parámetros query correctamente.",
            "status": "pending",
            "testStrategy": "Probar acceso a URLs canónicas y no-canónicas. Verificar redirecciones 301. Confirmar consistencia en URL structure.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Optimizar page titles y meta descriptions únicas",
            "description": "Implementar títulos de página y meta descriptions únicas y optimizadas",
            "dependencies": [],
            "details": "Crear sistema dinámico para títulos y meta descriptions. Desarrollar templates por tipo de contenido. Optimizar longitud (títulos 50-60 chars, descriptions 150-160 chars). Incluir keywords relevantes.",
            "status": "pending",
            "testStrategy": "Verificar que todas las páginas tengan títulos y descriptions únicas. Probar longitud óptima. Validar no contenido duplicado.",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Optimizar Core Web Vitals para SEO",
            "description": "Implementar optimizaciones para mejorar Core Web Vitals (LCP, FID, CLS)",
            "dependencies": [],
            "details": "Optimizar Largest Contentful Paint (imágenes, Web Fonts, server response). Mejorar First Input Delay (JS minimal, third-party scripts). Reducir Cumulative Layout Shift (dimensiones de imágenes, fuentes web).",
            "status": "pending",
            "testStrategy": "Medir Core Web Vitals con Google PageSpeed Insights. Probar LCP < 2.5s, FID < 100ms, CLS < 0.1. Verificar mejoras en producción.",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 7,
        "expansionPrompt": "Optimizar aplicación para motores de búsqueda. Meta tags optimizadas con Open Graph y Twitter Cards. Sitemap.xml generado automáticamente. Robots.txt configurado. Structured data con JSON-LD. URL canónicas y amigables. Page titles descriptivos. Meta descriptions únicas. Imágenes con alt text. Core Web Vitals optimizadas para SEO."
      },
      {
        "id": "45",
        "title": "Configurar analytics y métricas de negocio",
        "description": "Implementar sistema completo de medición según KPIs del PRD",
        "details": "Configurar Google Analytics 4 con custom events para engagement: comentarios, reacciones, tópicos creados. Funnels para registro y participación. Retención de usuarios medida. Time on site. Page views por categoría. Conversion tracking. Dashboard automatizado con KPIs: MAU, engagement rate, retention rate, content performance",
        "testStrategy": "Verificar que events se disparen correctamente, probar funnels de conversión, validar datos de retención, probar dashboard automático, y configurar alertas para KPIs críticos",
        "priority": "medium",
        "dependencies": [
          "31",
          "39"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configurar Google Analytics 4 y tracking básico",
            "description": "Inicializar Google Analytics 4 con el ID de medición y configurar el script de seguimiento básico en la aplicación",
            "dependencies": [],
            "details": "Crear cuenta en Google Analytics 4, obtener ID de medición (G-XXXXXXXXXX), configurar gtag.js en layout principal, instalar paquete @next/third-parties para Google Analytics, verificar que se inicialice correctamente en producción",
            "status": "pending",
            "testStrategy": "Verificar que el script de GA4 se carga correctamente usando Chrome DevTools Network tab, comprobar que gtag está definido globalmente, y validar que se envían pageviews automáticos",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar custom events para engagement de usuarios",
            "description": "Configurar eventos personalizados para medir comentarios, reacciones y creación de tópicos",
            "dependencies": [
              1
            ],
            "details": "Crear funciones de utilidad para trackEvent(event_name, parameters), implementar eventos: 'comment_created', 'reaction_added', 'topic_created', 'user_engagement'. Incluir parámetros relevantes como user_id, content_type, category. Usar TypeScript para tipado seguro de eventos",
            "status": "pending",
            "testStrategy": "Probar cada evento personalizado en Google Analytics Realtime reports, verificar que los parámetros se envían correctamente, y confirmar que los eventos aparecen en DebugView",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Configurar conversion funnels para registro y participación",
            "description": "Implementar seguimiento de embudos de conversión para medir el progreso de usuarios desde registro hasta participación activa",
            "dependencies": [
              2
            ],
            "details": "Definir funnel steps: 1) page_view (landing), 2) sign_up_start, 3) sign_up_complete, 4) first_interaction, 5) content_creation. Configurar eventos gtag('event', 'funnel_step', {'funnel_name': 'user_onboarding', 'step_number': X}). Crear dashboard personalizado en GA4",
            "status": "pending",
            "testStrategy": "Simular flujo completo de usuario desde landing hasta crear contenido, verificar que cada step se registre correctamente, y analizar funnel completion rate en GA4 Exploration",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implementar medición de retención y time on site",
            "description": "Configurar seguimiento de métricas de retención de usuarios y tiempo promedio en el sitio",
            "dependencies": [
              1
            ],
            "details": "Implementar session tracking con gtag('config', 'GA4_ID', {'session_duration': 1800}), configurar engagement_time_milliseconds para medir tiempo activo, crear eventos custom para 'session_start' y 'session_end'. Implementar user_id para seguimiento cross-session",
            "status": "pending",
            "testStrategy": "Probar tracking de sesiones con múltiples usuarios, validar que engagement time se calcula correctamente, y verificar retención metrics en GA4 Retention reports (necesita 7+ días de datos)",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Configurar page views por categoría y tracking de contenido",
            "description": "Implementar seguimiento detallado de páginas vistas organizadas por categorías de contenido",
            "dependencies": [
              1
            ],
            "details": "Extender pageview tracking con custom parameters: page_category, content_type, author_id. Configurar content grouping en GA4. Crear dimensiones personalizadas para categorías. Implementar virtual pageviews para SPAs si es necesario. Usar 'content_group' parameter",
            "status": "pending",
            "testStrategy": "Verificar que pageviews incluyan categorías correctas, probar content grouping en GA4, y validar que dimensiones personalizadas capturen datos de forma consistente",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Crear dashboard automatizado con KPIs principales",
            "description": "Desarrollar dashboard automatizado que muestre KPIs clave: MAU, engagement rate, retention rate, content performance",
            "dependencies": [
              2,
              3,
              4,
              5
            ],
            "details": "Configurar Google Data Studio con conectores a GA4, crear visualizaciones para: Monthly Active Users, Engagement Rate, Retention Rate (D1, D7, D30), Top Content Categories, Conversion Funnels. Implementar alertas automáticas para KPIs críticos. Agregar refresh diario de datos",
            "status": "pending",
            "testStrategy": "Verificar que el dashboard se actualice correctamente, probar alertas automáticas con thresholds definidos, y validar que todas las visualizaciones muestren datos precisos y en tiempo real",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 6,
        "expansionPrompt": "Implementar sistema completo de medición según KPIs del PRD. Configurar Google Analytics 4 con custom events para engagement: comentarios, reacciones, tópicos creados. Funnels para registro y participación. Retención de usuarios medida. Time on site. Page views por categoría. Conversion tracking. Dashboard automatizado con KPIs."
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-12-01T23:55:24.176Z",
      "taskCount": 45,
      "completedCount": 6,
      "tags": [
        "master"
      ]
    }
  }
}